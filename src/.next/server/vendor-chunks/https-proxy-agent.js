"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/https-proxy-agent";
exports.ids = ["vendor-chunks/https-proxy-agent"];
exports.modules = {

/***/ "(action-browser)/./node_modules/https-proxy-agent/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.HttpsProxyAgent = void 0;\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst tls = __importStar(__webpack_require__(/*! tls */ \"tls\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(action-browser)/./node_modules/debug/src/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(action-browser)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/index.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst parse_proxy_response_1 = __webpack_require__(/*! ./parse-proxy-response */ \"(action-browser)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js\");\nconst debug = (0, debug_1.default)(\"https-proxy-agent\");\nconst setServernameFromNonIpHost = (options)=>{\n    if (options.servername === undefined && options.host && !net.isIP(options.host)) {\n        return {\n            ...options,\n            servername: options.host\n        };\n    }\n    return options;\n};\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n */ class HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(proxy, opts){\n        super(opts);\n        this.options = {\n            path: undefined\n        };\n        this.proxy = typeof proxy === \"string\" ? new url_1.URL(proxy) : proxy;\n        this.proxyHeaders = opts?.headers ?? {};\n        debug(\"Creating new HttpsProxyAgent instance: %o\", this.proxy.href);\n        // Trim off the brackets from IPv6 addresses\n        const host = (this.proxy.hostname || this.proxy.host).replace(/^\\[|\\]$/g, \"\");\n        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === \"https:\" ? 443 : 80;\n        this.connectOpts = {\n            // Attempt to negotiate http/1.1 for proxy servers that support http/2\n            ALPNProtocols: [\n                \"http/1.1\"\n            ],\n            ...opts ? omit(opts, \"headers\") : null,\n            host,\n            port\n        };\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     */ async connect(req, opts) {\n        const { proxy } = this;\n        if (!opts.host) {\n            throw new TypeError('No \"host\" provided');\n        }\n        // Create a socket connection to the proxy server.\n        let socket;\n        if (proxy.protocol === \"https:\") {\n            debug(\"Creating `tls.Socket`: %o\", this.connectOpts);\n            socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));\n        } else {\n            debug(\"Creating `net.Socket`: %o\", this.connectOpts);\n            socket = net.connect(this.connectOpts);\n        }\n        const headers = typeof this.proxyHeaders === \"function\" ? this.proxyHeaders() : {\n            ...this.proxyHeaders\n        };\n        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;\n        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\\r\\n`;\n        // Inject the `Proxy-Authorization` header if necessary.\n        if (proxy.username || proxy.password) {\n            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;\n            headers[\"Proxy-Authorization\"] = `Basic ${Buffer.from(auth).toString(\"base64\")}`;\n        }\n        headers.Host = `${host}:${opts.port}`;\n        if (!headers[\"Proxy-Connection\"]) {\n            headers[\"Proxy-Connection\"] = this.keepAlive ? \"Keep-Alive\" : \"close\";\n        }\n        for (const name of Object.keys(headers)){\n            payload += `${name}: ${headers[name]}\\r\\n`;\n        }\n        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);\n        socket.write(`${payload}\\r\\n`);\n        const { connect, buffered } = await proxyResponsePromise;\n        req.emit(\"proxyConnect\", connect);\n        this.emit(\"proxyConnect\", connect, req);\n        if (connect.statusCode === 200) {\n            req.once(\"socket\", resume);\n            if (opts.secureEndpoint) {\n                // The proxy is connecting to a TLS server, so upgrade\n                // this socket connection to a TLS connection.\n                debug(\"Upgrading socket connection to TLS\");\n                return tls.connect({\n                    ...omit(setServernameFromNonIpHost(opts), \"host\", \"path\", \"port\"),\n                    socket\n                });\n            }\n            return socket;\n        }\n        // Some other status code that's not 200... need to re-play the HTTP\n        // header \"data\" events onto the socket once the HTTP machinery is\n        // attached so that the node core `http` can parse and handle the\n        // error status code.\n        // Close the original socket, and a new \"fake\" socket is returned\n        // instead, so that the proxy doesn't get the HTTP request\n        // written to it (which may contain `Authorization` headers or other\n        // sensitive data).\n        //\n        // See: https://hackerone.com/reports/541502\n        socket.destroy();\n        const fakeSocket = new net.Socket({\n            writable: false\n        });\n        fakeSocket.readable = true;\n        // Need to wait for the \"socket\" event to re-play the \"data\" events.\n        req.once(\"socket\", (s)=>{\n            debug(\"Replaying proxy buffer for failed request\");\n            (0, assert_1.default)(s.listenerCount(\"data\") > 0);\n            // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n            // this point the HTTP module machinery has been hooked up for\n            // the user.\n            s.push(buffered);\n            s.push(null);\n        });\n        return fakeSocket;\n    }\n}\nHttpsProxyAgent.protocols = [\n    \"http\",\n    \"https\"\n];\nexports.HttpsProxyAgent = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for(key in obj){\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLENBQUMsTUFBRyxLQUFL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LFdBQVdFLFFBQVEsR0FBRztRQUN0QixvRUFBb0U7UUFDcEU1QixJQUFJc0IsSUFBSSxDQUFDLFVBQVUsQ0FBQ087WUFDaEJ0RCxNQUFNO1lBQ0wsSUFBR0wsU0FBU00sT0FBTyxFQUFFcUQsRUFBRUMsYUFBYSxDQUFDLFVBQVU7WUFDaEQsZ0VBQWdFO1lBQ2hFLDhEQUE4RDtZQUM5RCxZQUFZO1lBQ1pELEVBQUVFLElBQUksQ0FBQ1o7WUFDUFUsRUFBRUUsSUFBSSxDQUFDO1FBQ1g7UUFDQSxPQUFPTDtJQUNYO0FBQ0o7QUFDQTVELGdCQUFnQmtFLFNBQVMsR0FBRztJQUFDO0lBQVE7Q0FBUTtBQUM3Q25FLHVCQUF1QixHQUFHQztBQUMxQixTQUFTeUQsT0FBT3JCLE1BQU07SUFDbEJBLE9BQU9xQixNQUFNO0FBQ2pCO0FBQ0EsU0FBU3pCLEtBQUttQyxHQUFHLEVBQUUsR0FBR2xCLElBQUk7SUFDdEIsTUFBTW1CLE1BQU0sQ0FBQztJQUNiLElBQUlDO0lBQ0osSUFBS0EsT0FBT0YsSUFBSztRQUNiLElBQUksQ0FBQ2xCLEtBQUtxQixRQUFRLENBQUNELE1BQU07WUFDckJELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHRixHQUFHLENBQUNFLElBQUk7UUFDdkI7SUFDSjtJQUNBLE9BQU9EO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9henVyZS1vcGVuLWFpLWFjY2VsZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanM/ZjJmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwc1Byb3h5QWdlbnQgPSB2b2lkIDA7XG5jb25zdCBuZXQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm5ldFwiKSk7XG5jb25zdCB0bHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInRsc1wiKSk7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGFnZW50X2Jhc2VfMSA9IHJlcXVpcmUoXCJhZ2VudC1iYXNlXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgcGFyc2VfcHJveHlfcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL3BhcnNlLXByb3h5LXJlc3BvbnNlXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnaHR0cHMtcHJveHktYWdlbnQnKTtcbmNvbnN0IHNldFNlcnZlcm5hbWVGcm9tTm9uSXBIb3N0ID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAob3B0aW9ucy5zZXJ2ZXJuYW1lID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgb3B0aW9ucy5ob3N0ICYmXG4gICAgICAgICFuZXQuaXNJUChvcHRpb25zLmhvc3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgc2VydmVybmFtZTogb3B0aW9ucy5ob3N0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4vKipcbiAqIFRoZSBgSHR0cHNQcm94eUFnZW50YCBpbXBsZW1lbnRzIGFuIEhUVFAgQWdlbnQgc3ViY2xhc3MgdGhhdCBjb25uZWN0cyB0b1xuICogdGhlIHNwZWNpZmllZCBcIkhUVFAocykgcHJveHkgc2VydmVyXCIgaW4gb3JkZXIgdG8gcHJveHkgSFRUUFMgcmVxdWVzdHMuXG4gKlxuICogT3V0Z29pbmcgSFRUUCByZXF1ZXN0cyBhcmUgZmlyc3QgdHVubmVsZWQgdGhyb3VnaCB0aGUgcHJveHkgc2VydmVyIHVzaW5nIHRoZVxuICogYENPTk5FQ1RgIEhUVFAgcmVxdWVzdCBtZXRob2QgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyLFxuICogYW5kIHRoZW4gdGhlIHByb3h5IHNlcnZlciBjb25uZWN0cyB0byB0aGUgZGVzdGluYXRpb24gdGFyZ2V0IGFuZCBpc3N1ZXMgdGhlXG4gKiBIVFRQIHJlcXVlc3QgZnJvbSB0aGUgcHJveHkgc2VydmVyLlxuICpcbiAqIGBodHRwczpgIHJlcXVlc3RzIGhhdmUgdGhlaXIgc29ja2V0IGNvbm5lY3Rpb24gdXBncmFkZWQgdG8gVExTIG9uY2VcbiAqIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gKi9cbmNsYXNzIEh0dHBzUHJveHlBZ2VudCBleHRlbmRzIGFnZW50X2Jhc2VfMS5BZ2VudCB7XG4gICAgY29uc3RydWN0b3IocHJveHksIG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHsgcGF0aDogdW5kZWZpbmVkIH07XG4gICAgICAgIHRoaXMucHJveHkgPSB0eXBlb2YgcHJveHkgPT09ICdzdHJpbmcnID8gbmV3IHVybF8xLlVSTChwcm94eSkgOiBwcm94eTtcbiAgICAgICAgdGhpcy5wcm94eUhlYWRlcnMgPSBvcHRzPy5oZWFkZXJzID8/IHt9O1xuICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgbmV3IEh0dHBzUHJveHlBZ2VudCBpbnN0YW5jZTogJW8nLCB0aGlzLnByb3h5LmhyZWYpO1xuICAgICAgICAvLyBUcmltIG9mZiB0aGUgYnJhY2tldHMgZnJvbSBJUHY2IGFkZHJlc3Nlc1xuICAgICAgICBjb25zdCBob3N0ID0gKHRoaXMucHJveHkuaG9zdG5hbWUgfHwgdGhpcy5wcm94eS5ob3N0KS5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICBjb25zdCBwb3J0ID0gdGhpcy5wcm94eS5wb3J0XG4gICAgICAgICAgICA/IHBhcnNlSW50KHRoaXMucHJveHkucG9ydCwgMTApXG4gICAgICAgICAgICA6IHRoaXMucHJveHkucHJvdG9jb2wgPT09ICdodHRwczonXG4gICAgICAgICAgICAgICAgPyA0NDNcbiAgICAgICAgICAgICAgICA6IDgwO1xuICAgICAgICB0aGlzLmNvbm5lY3RPcHRzID0ge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBuZWdvdGlhdGUgaHR0cC8xLjEgZm9yIHByb3h5IHNlcnZlcnMgdGhhdCBzdXBwb3J0IGh0dHAvMlxuICAgICAgICAgICAgQUxQTlByb3RvY29sczogWydodHRwLzEuMSddLFxuICAgICAgICAgICAgLi4uKG9wdHMgPyBvbWl0KG9wdHMsICdoZWFkZXJzJykgOiBudWxsKSxcbiAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICBwb3J0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbm9kZS1jb3JlIEhUVFAgY2xpZW50IGxpYnJhcnkgaXMgY3JlYXRpbmcgYVxuICAgICAqIG5ldyBIVFRQIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdChyZXEsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBwcm94eSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzLmhvc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIFwiaG9zdFwiIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgc29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlci5cbiAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgaWYgKHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgZGVidWcoJ0NyZWF0aW5nIGB0bHMuU29ja2V0YDogJW8nLCB0aGlzLmNvbm5lY3RPcHRzKTtcbiAgICAgICAgICAgIHNvY2tldCA9IHRscy5jb25uZWN0KHNldFNlcnZlcm5hbWVGcm9tTm9uSXBIb3N0KHRoaXMuY29ubmVjdE9wdHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKCdDcmVhdGluZyBgbmV0LlNvY2tldGA6ICVvJywgdGhpcy5jb25uZWN0T3B0cyk7XG4gICAgICAgICAgICBzb2NrZXQgPSBuZXQuY29ubmVjdCh0aGlzLmNvbm5lY3RPcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gdHlwZW9mIHRoaXMucHJveHlIZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHRoaXMucHJveHlIZWFkZXJzKClcbiAgICAgICAgICAgIDogeyAuLi50aGlzLnByb3h5SGVhZGVycyB9O1xuICAgICAgICBjb25zdCBob3N0ID0gbmV0LmlzSVB2NihvcHRzLmhvc3QpID8gYFske29wdHMuaG9zdH1dYCA6IG9wdHMuaG9zdDtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBgQ09OTkVDVCAke2hvc3R9OiR7b3B0cy5wb3J0fSBIVFRQLzEuMVxcclxcbmA7XG4gICAgICAgIC8vIEluamVjdCB0aGUgYFByb3h5LUF1dGhvcml6YXRpb25gIGhlYWRlciBpZiBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChwcm94eS51c2VybmFtZSB8fCBwcm94eS5wYXNzd29yZCkge1xuICAgICAgICAgICAgY29uc3QgYXV0aCA9IGAke2RlY29kZVVSSUNvbXBvbmVudChwcm94eS51c2VybmFtZSl9OiR7ZGVjb2RlVVJJQ29tcG9uZW50KHByb3h5LnBhc3N3b3JkKX1gO1xuICAgICAgICAgICAgaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycy5Ib3N0ID0gYCR7aG9zdH06JHtvcHRzLnBvcnR9YDtcbiAgICAgICAgaWYgKCFoZWFkZXJzWydQcm94eS1Db25uZWN0aW9uJ10pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ1Byb3h5LUNvbm5lY3Rpb24nXSA9IHRoaXMua2VlcEFsaXZlXG4gICAgICAgICAgICAgICAgPyAnS2VlcC1BbGl2ZSdcbiAgICAgICAgICAgICAgICA6ICdjbG9zZSc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICBwYXlsb2FkICs9IGAke25hbWV9OiAke2hlYWRlcnNbbmFtZV19XFxyXFxuYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm94eVJlc3BvbnNlUHJvbWlzZSA9ICgwLCBwYXJzZV9wcm94eV9yZXNwb25zZV8xLnBhcnNlUHJveHlSZXNwb25zZSkoc29ja2V0KTtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke3BheWxvYWR9XFxyXFxuYCk7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdCwgYnVmZmVyZWQgfSA9IGF3YWl0IHByb3h5UmVzcG9uc2VQcm9taXNlO1xuICAgICAgICByZXEuZW1pdCgncHJveHlDb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgIHRoaXMuZW1pdCgncHJveHlDb25uZWN0JywgY29ubmVjdCwgcmVxKTtcbiAgICAgICAgaWYgKGNvbm5lY3Quc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXEub25jZSgnc29ja2V0JywgcmVzdW1lKTtcbiAgICAgICAgICAgIGlmIChvcHRzLnNlY3VyZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByb3h5IGlzIGNvbm5lY3RpbmcgdG8gYSBUTFMgc2VydmVyLCBzbyB1cGdyYWRlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzb2NrZXQgY29ubmVjdGlvbiB0byBhIFRMUyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgIGRlYnVnKCdVcGdyYWRpbmcgc29ja2V0IGNvbm5lY3Rpb24gdG8gVExTJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRscy5jb25uZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgLi4ub21pdChzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdChvcHRzKSwgJ2hvc3QnLCAncGF0aCcsICdwb3J0JyksXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBvdGhlciBzdGF0dXMgY29kZSB0aGF0J3Mgbm90IDIwMC4uLiBuZWVkIHRvIHJlLXBsYXkgdGhlIEhUVFBcbiAgICAgICAgLy8gaGVhZGVyIFwiZGF0YVwiIGV2ZW50cyBvbnRvIHRoZSBzb2NrZXQgb25jZSB0aGUgSFRUUCBtYWNoaW5lcnkgaXNcbiAgICAgICAgLy8gYXR0YWNoZWQgc28gdGhhdCB0aGUgbm9kZSBjb3JlIGBodHRwYCBjYW4gcGFyc2UgYW5kIGhhbmRsZSB0aGVcbiAgICAgICAgLy8gZXJyb3Igc3RhdHVzIGNvZGUuXG4gICAgICAgIC8vIENsb3NlIHRoZSBvcmlnaW5hbCBzb2NrZXQsIGFuZCBhIG5ldyBcImZha2VcIiBzb2NrZXQgaXMgcmV0dXJuZWRcbiAgICAgICAgLy8gaW5zdGVhZCwgc28gdGhhdCB0aGUgcHJveHkgZG9lc24ndCBnZXQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAgICAvLyB3cml0dGVuIHRvIGl0ICh3aGljaCBtYXkgY29udGFpbiBgQXV0aG9yaXphdGlvbmAgaGVhZGVycyBvciBvdGhlclxuICAgICAgICAvLyBzZW5zaXRpdmUgZGF0YSkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9oYWNrZXJvbmUuY29tL3JlcG9ydHMvNTQxNTAyXG4gICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIGNvbnN0IGZha2VTb2NrZXQgPSBuZXcgbmV0LlNvY2tldCh7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgZmFrZVNvY2tldC5yZWFkYWJsZSA9IHRydWU7XG4gICAgICAgIC8vIE5lZWQgdG8gd2FpdCBmb3IgdGhlIFwic29ja2V0XCIgZXZlbnQgdG8gcmUtcGxheSB0aGUgXCJkYXRhXCIgZXZlbnRzLlxuICAgICAgICByZXEub25jZSgnc29ja2V0JywgKHMpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKCdSZXBsYXlpbmcgcHJveHkgYnVmZmVyIGZvciBmYWlsZWQgcmVxdWVzdCcpO1xuICAgICAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKHMubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCk7XG4gICAgICAgICAgICAvLyBSZXBsYXkgdGhlIFwiYnVmZmVyZWRcIiBCdWZmZXIgb250byB0aGUgZmFrZSBgc29ja2V0YCwgc2luY2UgYXRcbiAgICAgICAgICAgIC8vIHRoaXMgcG9pbnQgdGhlIEhUVFAgbW9kdWxlIG1hY2hpbmVyeSBoYXMgYmVlbiBob29rZWQgdXAgZm9yXG4gICAgICAgICAgICAvLyB0aGUgdXNlci5cbiAgICAgICAgICAgIHMucHVzaChidWZmZXJlZCk7XG4gICAgICAgICAgICBzLnB1c2gobnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFrZVNvY2tldDtcbiAgICB9XG59XG5IdHRwc1Byb3h5QWdlbnQucHJvdG9jb2xzID0gWydodHRwJywgJ2h0dHBzJ107XG5leHBvcnRzLkh0dHBzUHJveHlBZ2VudCA9IEh0dHBzUHJveHlBZ2VudDtcbmZ1bmN0aW9uIHJlc3VtZShzb2NrZXQpIHtcbiAgICBzb2NrZXQucmVzdW1lKCk7XG59XG5mdW5jdGlvbiBvbWl0KG9iaiwgLi4ua2V5cykge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsIkh0dHBzUHJveHlBZ2VudCIsIm5ldCIsInJlcXVpcmUiLCJ0bHMiLCJhc3NlcnRfMSIsImRlYnVnXzEiLCJhZ2VudF9iYXNlXzEiLCJ1cmxfMSIsInBhcnNlX3Byb3h5X3Jlc3BvbnNlXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdCIsIm9wdGlvbnMiLCJzZXJ2ZXJuYW1lIiwiaG9zdCIsImlzSVAiLCJBZ2VudCIsImNvbnN0cnVjdG9yIiwicHJveHkiLCJvcHRzIiwicGF0aCIsIlVSTCIsInByb3h5SGVhZGVycyIsImhlYWRlcnMiLCJocmVmIiwiaG9zdG5hbWUiLCJyZXBsYWNlIiwicG9ydCIsInBhcnNlSW50IiwicHJvdG9jb2wiLCJjb25uZWN0T3B0cyIsIkFMUE5Qcm90b2NvbHMiLCJvbWl0IiwiY29ubmVjdCIsInJlcSIsIlR5cGVFcnJvciIsInNvY2tldCIsImlzSVB2NiIsInBheWxvYWQiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiYXV0aCIsImRlY29kZVVSSUNvbXBvbmVudCIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIkhvc3QiLCJrZWVwQWxpdmUiLCJuYW1lIiwia2V5cyIsInByb3h5UmVzcG9uc2VQcm9taXNlIiwicGFyc2VQcm94eVJlc3BvbnNlIiwid3JpdGUiLCJidWZmZXJlZCIsImVtaXQiLCJzdGF0dXNDb2RlIiwib25jZSIsInJlc3VtZSIsInNlY3VyZUVuZHBvaW50IiwiZGVzdHJveSIsImZha2VTb2NrZXQiLCJTb2NrZXQiLCJyZWFkYWJsZSIsInMiLCJsaXN0ZW5lckNvdW50IiwicHVzaCIsInByb3RvY29scyIsIm9iaiIsInJldCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/https-proxy-agent/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/https-proxy-agent/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.HttpsProxyAgent = void 0;\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst tls = __importStar(__webpack_require__(/*! tls */ \"tls\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/index.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst parse_proxy_response_1 = __webpack_require__(/*! ./parse-proxy-response */ \"(rsc)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js\");\nconst debug = (0, debug_1.default)(\"https-proxy-agent\");\nconst setServernameFromNonIpHost = (options)=>{\n    if (options.servername === undefined && options.host && !net.isIP(options.host)) {\n        return {\n            ...options,\n            servername: options.host\n        };\n    }\n    return options;\n};\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n */ class HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(proxy, opts){\n        super(opts);\n        this.options = {\n            path: undefined\n        };\n        this.proxy = typeof proxy === \"string\" ? new url_1.URL(proxy) : proxy;\n        this.proxyHeaders = opts?.headers ?? {};\n        debug(\"Creating new HttpsProxyAgent instance: %o\", this.proxy.href);\n        // Trim off the brackets from IPv6 addresses\n        const host = (this.proxy.hostname || this.proxy.host).replace(/^\\[|\\]$/g, \"\");\n        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === \"https:\" ? 443 : 80;\n        this.connectOpts = {\n            // Attempt to negotiate http/1.1 for proxy servers that support http/2\n            ALPNProtocols: [\n                \"http/1.1\"\n            ],\n            ...opts ? omit(opts, \"headers\") : null,\n            host,\n            port\n        };\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     */ async connect(req, opts) {\n        const { proxy } = this;\n        if (!opts.host) {\n            throw new TypeError('No \"host\" provided');\n        }\n        // Create a socket connection to the proxy server.\n        let socket;\n        if (proxy.protocol === \"https:\") {\n            debug(\"Creating `tls.Socket`: %o\", this.connectOpts);\n            socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));\n        } else {\n            debug(\"Creating `net.Socket`: %o\", this.connectOpts);\n            socket = net.connect(this.connectOpts);\n        }\n        const headers = typeof this.proxyHeaders === \"function\" ? this.proxyHeaders() : {\n            ...this.proxyHeaders\n        };\n        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;\n        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\\r\\n`;\n        // Inject the `Proxy-Authorization` header if necessary.\n        if (proxy.username || proxy.password) {\n            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;\n            headers[\"Proxy-Authorization\"] = `Basic ${Buffer.from(auth).toString(\"base64\")}`;\n        }\n        headers.Host = `${host}:${opts.port}`;\n        if (!headers[\"Proxy-Connection\"]) {\n            headers[\"Proxy-Connection\"] = this.keepAlive ? \"Keep-Alive\" : \"close\";\n        }\n        for (const name of Object.keys(headers)){\n            payload += `${name}: ${headers[name]}\\r\\n`;\n        }\n        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);\n        socket.write(`${payload}\\r\\n`);\n        const { connect, buffered } = await proxyResponsePromise;\n        req.emit(\"proxyConnect\", connect);\n        this.emit(\"proxyConnect\", connect, req);\n        if (connect.statusCode === 200) {\n            req.once(\"socket\", resume);\n            if (opts.secureEndpoint) {\n                // The proxy is connecting to a TLS server, so upgrade\n                // this socket connection to a TLS connection.\n                debug(\"Upgrading socket connection to TLS\");\n                return tls.connect({\n                    ...omit(setServernameFromNonIpHost(opts), \"host\", \"path\", \"port\"),\n                    socket\n                });\n            }\n            return socket;\n        }\n        // Some other status code that's not 200... need to re-play the HTTP\n        // header \"data\" events onto the socket once the HTTP machinery is\n        // attached so that the node core `http` can parse and handle the\n        // error status code.\n        // Close the original socket, and a new \"fake\" socket is returned\n        // instead, so that the proxy doesn't get the HTTP request\n        // written to it (which may contain `Authorization` headers or other\n        // sensitive data).\n        //\n        // See: https://hackerone.com/reports/541502\n        socket.destroy();\n        const fakeSocket = new net.Socket({\n            writable: false\n        });\n        fakeSocket.readable = true;\n        // Need to wait for the \"socket\" event to re-play the \"data\" events.\n        req.once(\"socket\", (s)=>{\n            debug(\"Replaying proxy buffer for failed request\");\n            (0, assert_1.default)(s.listenerCount(\"data\") > 0);\n            // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n            // this point the HTTP module machinery has been hooked up for\n            // the user.\n            s.push(buffered);\n            s.push(null);\n        });\n        return fakeSocket;\n    }\n}\nHttpsProxyAgent.protocols = [\n    \"http\",\n    \"https\"\n];\nexports.HttpsProxyAgent = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for(key in obj){\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFVQyxHQUFHO0lBQzNELElBQUlBLE9BQU9BLElBQUlWLFVBQVUsRUFBRSxPQUFPVTtJQUNsQyxJQUFJQyxTQUFTLENBQUM7SUFDZCxJQUFJRCxPQUFPLE1BQU07UUFBQSxJQUFLLElBQUlmLEtBQUtlLElBQUssSUFBSWYsTUFBTSxhQUFhSixPQUFPcUIsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osS0FBS2YsSUFBSUwsZ0JBQWdCcUIsUUFBUUQsS0FBS2Y7SUFBRTtJQUN4SVcsbUJBQW1CSyxRQUFRRDtJQUMzQixPQUFPQztBQUNYO0FBQ0EsSUFBSUksa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVMLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJVixVQUFVLEdBQUlVLE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FuQiw4Q0FBNkM7SUFBRWlCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RRLHVCQUF1QixHQUFHLEtBQUs7QUFDL0IsTUFBTUUsTUFBTVQsYUFBYVUsbUJBQU9BLENBQUMsZ0JBQUs7QUFDdEMsTUFBTUMsTUFBTVgsYUFBYVUsbUJBQU9BLENBQUMsZ0JBQUs7QUFDdEMsTUFBTUUsV0FBV04sZ0JBQWdCSSxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqRCxNQUFNRyxVQUFVUCxnQkFBZ0JJLG1CQUFPQSxDQUFDLHNEQUFPO0FBQy9DLE1BQU1JLGVBQWVKLG1CQUFPQSxDQUFDLGdHQUFZO0FBQ3pDLE1BQU1LLFFBQVFMLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1NLHlCQUF5Qk4sbUJBQU9BLENBQUMsbUdBQXdCO0FBQy9ELE1BQU1PLFFBQVEsQ0FBQyxHQUFHSixRQUFRSyxPQUFPLEVBQUU7QUFDbkMsTUFBTUMsNkJBQTZCLENBQUNDO0lBQ2hDLElBQUlBLFFBQVFDLFVBQVUsS0FBS2pDLGFBQ3ZCZ0MsUUFBUUUsSUFBSSxJQUNaLENBQUNiLElBQUljLElBQUksQ0FBQ0gsUUFBUUUsSUFBSSxHQUFHO1FBQ3pCLE9BQU87WUFDSCxHQUFHRixPQUFPO1lBQ1ZDLFlBQVlELFFBQVFFLElBQUk7UUFDNUI7SUFDSjtJQUNBLE9BQU9GO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELE1BQU1aLHdCQUF3Qk0sYUFBYVUsS0FBSztJQUM1Q0MsWUFBWUMsS0FBSyxFQUFFQyxJQUFJLENBQUU7UUFDckIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ1AsT0FBTyxHQUFHO1lBQUVRLE1BQU14QztRQUFVO1FBQ2pDLElBQUksQ0FBQ3NDLEtBQUssR0FBRyxPQUFPQSxVQUFVLFdBQVcsSUFBSVgsTUFBTWMsR0FBRyxDQUFDSCxTQUFTQTtRQUNoRSxJQUFJLENBQUNJLFlBQVksR0FBR0gsTUFBTUksV0FBVyxDQUFDO1FBQ3RDZCxNQUFNLDZDQUE2QyxJQUFJLENBQUNTLEtBQUssQ0FBQ00sSUFBSTtRQUNsRSw0Q0FBNEM7UUFDNUMsTUFBTVYsT0FBTyxDQUFDLElBQUksQ0FBQ0ksS0FBSyxDQUFDTyxRQUFRLElBQUksSUFBSSxDQUFDUCxLQUFLLENBQUNKLElBQUksRUFBRVksT0FBTyxDQUFDLFlBQVk7UUFDMUUsTUFBTUMsT0FBTyxJQUFJLENBQUNULEtBQUssQ0FBQ1MsSUFBSSxHQUN0QkMsU0FBUyxJQUFJLENBQUNWLEtBQUssQ0FBQ1MsSUFBSSxFQUFFLE1BQzFCLElBQUksQ0FBQ1QsS0FBSyxDQUFDVyxRQUFRLEtBQUssV0FDcEIsTUFDQTtRQUNWLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1lBQ2Ysc0VBQXNFO1lBQ3RFQyxlQUFlO2dCQUFDO2FBQVc7WUFDM0IsR0FBSVosT0FBT2EsS0FBS2IsTUFBTSxhQUFhLElBQUk7WUFDdkNMO1lBQ0FhO1FBQ0o7SUFDSjtJQUNBOzs7S0FHQyxHQUNELE1BQU1NLFFBQVFDLEdBQUcsRUFBRWYsSUFBSSxFQUFFO1FBQ3JCLE1BQU0sRUFBRUQsS0FBSyxFQUFFLEdBQUcsSUFBSTtRQUN0QixJQUFJLENBQUNDLEtBQUtMLElBQUksRUFBRTtZQUNaLE1BQU0sSUFBSXFCLFVBQVU7UUFDeEI7UUFDQSxrREFBa0Q7UUFDbEQsSUFBSUM7UUFDSixJQUFJbEIsTUFBTVcsUUFBUSxLQUFLLFVBQVU7WUFDN0JwQixNQUFNLDZCQUE2QixJQUFJLENBQUNxQixXQUFXO1lBQ25ETSxTQUFTakMsSUFBSThCLE9BQU8sQ0FBQ3RCLDJCQUEyQixJQUFJLENBQUNtQixXQUFXO1FBQ3BFLE9BQ0s7WUFDRHJCLE1BQU0sNkJBQTZCLElBQUksQ0FBQ3FCLFdBQVc7WUFDbkRNLFNBQVNuQyxJQUFJZ0MsT0FBTyxDQUFDLElBQUksQ0FBQ0gsV0FBVztRQUN6QztRQUNBLE1BQU1QLFVBQVUsT0FBTyxJQUFJLENBQUNELFlBQVksS0FBSyxhQUN2QyxJQUFJLENBQUNBLFlBQVksS0FDakI7WUFBRSxHQUFHLElBQUksQ0FBQ0EsWUFBWTtRQUFDO1FBQzdCLE1BQU1SLE9BQU9iLElBQUlvQyxNQUFNLENBQUNsQixLQUFLTCxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUVLLEtBQUtMLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBR0ssS0FBS0wsSUFBSTtRQUNqRSxJQUFJd0IsVUFBVSxDQUFDLFFBQVEsRUFBRXhCLEtBQUssQ0FBQyxFQUFFSyxLQUFLUSxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQ3pELHdEQUF3RDtRQUN4RCxJQUFJVCxNQUFNcUIsUUFBUSxJQUFJckIsTUFBTXNCLFFBQVEsRUFBRTtZQUNsQyxNQUFNQyxPQUFPLENBQUMsRUFBRUMsbUJBQW1CeEIsTUFBTXFCLFFBQVEsRUFBRSxDQUFDLEVBQUVHLG1CQUFtQnhCLE1BQU1zQixRQUFRLEVBQUUsQ0FBQztZQUMxRmpCLE9BQU8sQ0FBQyxzQkFBc0IsR0FBRyxDQUFDLE1BQU0sRUFBRW9CLE9BQU9DLElBQUksQ0FBQ0gsTUFBTUksUUFBUSxDQUFDLFVBQVUsQ0FBQztRQUNwRjtRQUNBdEIsUUFBUXVCLElBQUksR0FBRyxDQUFDLEVBQUVoQyxLQUFLLENBQUMsRUFBRUssS0FBS1EsSUFBSSxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDSixPQUFPLENBQUMsbUJBQW1CLEVBQUU7WUFDOUJBLE9BQU8sQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUN3QixTQUFTLEdBQ3RDLGVBQ0E7UUFDVjtRQUNBLEtBQUssTUFBTUMsUUFBUTFFLE9BQU8yRSxJQUFJLENBQUMxQixTQUFVO1lBQ3JDZSxXQUFXLENBQUMsRUFBRVUsS0FBSyxFQUFFLEVBQUV6QixPQUFPLENBQUN5QixLQUFLLENBQUMsSUFBSSxDQUFDO1FBQzlDO1FBQ0EsTUFBTUUsdUJBQXVCLENBQUMsR0FBRzFDLHVCQUF1QjJDLGtCQUFrQixFQUFFZjtRQUM1RUEsT0FBT2dCLEtBQUssQ0FBQyxDQUFDLEVBQUVkLFFBQVEsSUFBSSxDQUFDO1FBQzdCLE1BQU0sRUFBRUwsT0FBTyxFQUFFb0IsUUFBUSxFQUFFLEdBQUcsTUFBTUg7UUFDcENoQixJQUFJb0IsSUFBSSxDQUFDLGdCQUFnQnJCO1FBQ3pCLElBQUksQ0FBQ3FCLElBQUksQ0FBQyxnQkFBZ0JyQixTQUFTQztRQUNuQyxJQUFJRCxRQUFRc0IsVUFBVSxLQUFLLEtBQUs7WUFDNUJyQixJQUFJc0IsSUFBSSxDQUFDLFVBQVVDO1lBQ25CLElBQUl0QyxLQUFLdUMsY0FBYyxFQUFFO2dCQUNyQixzREFBc0Q7Z0JBQ3RELDhDQUE4QztnQkFDOUNqRCxNQUFNO2dCQUNOLE9BQU9OLElBQUk4QixPQUFPLENBQUM7b0JBQ2YsR0FBR0QsS0FBS3JCLDJCQUEyQlEsT0FBTyxRQUFRLFFBQVEsT0FBTztvQkFDakVpQjtnQkFDSjtZQUNKO1lBQ0EsT0FBT0E7UUFDWDtRQUNBLG9FQUFvRTtRQUNwRSxrRUFBa0U7UUFDbEUsaUVBQWlFO1FBQ2pFLHFCQUFxQjtRQUNyQixpRUFBaUU7UUFDakUsMERBQTBEO1FBQzFELG9FQUFvRTtRQUNwRSxtQkFBbUI7UUFDbkIsRUFBRTtRQUNGLDRDQUE0QztRQUM1Q0EsT0FBT3VCLE9BQU87UUFDZCxNQUFNQyxhQUFhLElBQUkzRCxJQUFJNEQsTUFBTSxDQUFDO1lBQUU3RSxVQUFVO1FBQU07UUFDcEQ0RSxXQUFXRSxRQUFRLEdBQUc7UUFDdEIsb0VBQW9FO1FBQ3BFNUIsSUFBSXNCLElBQUksQ0FBQyxVQUFVLENBQUNPO1lBQ2hCdEQsTUFBTTtZQUNMLElBQUdMLFNBQVNNLE9BQU8sRUFBRXFELEVBQUVDLGFBQWEsQ0FBQyxVQUFVO1lBQ2hELGdFQUFnRTtZQUNoRSw4REFBOEQ7WUFDOUQsWUFBWTtZQUNaRCxFQUFFRSxJQUFJLENBQUNaO1lBQ1BVLEVBQUVFLElBQUksQ0FBQztRQUNYO1FBQ0EsT0FBT0w7SUFDWDtBQUNKO0FBQ0E1RCxnQkFBZ0JrRSxTQUFTLEdBQUc7SUFBQztJQUFRO0NBQVE7QUFDN0NuRSx1QkFBdUIsR0FBR0M7QUFDMUIsU0FBU3lELE9BQU9yQixNQUFNO0lBQ2xCQSxPQUFPcUIsTUFBTTtBQUNqQjtBQUNBLFNBQVN6QixLQUFLbUMsR0FBRyxFQUFFLEdBQUdsQixJQUFJO0lBQ3RCLE1BQU1tQixNQUFNLENBQUM7SUFDYixJQUFJQztJQUNKLElBQUtBLE9BQU9GLElBQUs7UUFDYixJQUFJLENBQUNsQixLQUFLcUIsUUFBUSxDQUFDRCxNQUFNO1lBQ3JCRCxHQUFHLENBQUNDLElBQUksR0FBR0YsR0FBRyxDQUFDRSxJQUFJO1FBQ3ZCO0lBQ0o7SUFDQSxPQUFPRDtBQUNYLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXp1cmUtb3Blbi1haS1hY2NlbGVyYXRvci8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzP2YyZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cHNQcm94eUFnZW50ID0gdm9pZCAwO1xuY29uc3QgbmV0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJuZXRcIikpO1xuY29uc3QgdGxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ0bHNcIikpO1xuY29uc3QgYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBhZ2VudF9iYXNlXzEgPSByZXF1aXJlKFwiYWdlbnQtYmFzZVwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHBhcnNlX3Byb3h5X3Jlc3BvbnNlXzEgPSByZXF1aXJlKFwiLi9wYXJzZS1wcm94eS1yZXNwb25zZVwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ2h0dHBzLXByb3h5LWFnZW50Jyk7XG5jb25zdCBzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdCA9IChvcHRpb25zKSA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VydmVybmFtZSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG9wdGlvbnMuaG9zdCAmJlxuICAgICAgICAhbmV0LmlzSVAob3B0aW9ucy5ob3N0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHNlcnZlcm5hbWU6IG9wdGlvbnMuaG9zdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuLyoqXG4gKiBUaGUgYEh0dHBzUHJveHlBZ2VudGAgaW1wbGVtZW50cyBhbiBIVFRQIEFnZW50IHN1YmNsYXNzIHRoYXQgY29ubmVjdHMgdG9cbiAqIHRoZSBzcGVjaWZpZWQgXCJIVFRQKHMpIHByb3h5IHNlcnZlclwiIGluIG9yZGVyIHRvIHByb3h5IEhUVFBTIHJlcXVlc3RzLlxuICpcbiAqIE91dGdvaW5nIEhUVFAgcmVxdWVzdHMgYXJlIGZpcnN0IHR1bm5lbGVkIHRocm91Z2ggdGhlIHByb3h5IHNlcnZlciB1c2luZyB0aGVcbiAqIGBDT05ORUNUYCBIVFRQIHJlcXVlc3QgbWV0aG9kIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlcixcbiAqIGFuZCB0aGVuIHRoZSBwcm94eSBzZXJ2ZXIgY29ubmVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIHRhcmdldCBhbmQgaXNzdWVzIHRoZVxuICogSFRUUCByZXF1ZXN0IGZyb20gdGhlIHByb3h5IHNlcnZlci5cbiAqXG4gKiBgaHR0cHM6YCByZXF1ZXN0cyBoYXZlIHRoZWlyIHNvY2tldCBjb25uZWN0aW9uIHVwZ3JhZGVkIHRvIFRMUyBvbmNlXG4gKiB0aGUgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICovXG5jbGFzcyBIdHRwc1Byb3h5QWdlbnQgZXh0ZW5kcyBhZ2VudF9iYXNlXzEuQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3h5LCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7IHBhdGg6IHVuZGVmaW5lZCB9O1xuICAgICAgICB0aGlzLnByb3h5ID0gdHlwZW9mIHByb3h5ID09PSAnc3RyaW5nJyA/IG5ldyB1cmxfMS5VUkwocHJveHkpIDogcHJveHk7XG4gICAgICAgIHRoaXMucHJveHlIZWFkZXJzID0gb3B0cz8uaGVhZGVycyA/PyB7fTtcbiAgICAgICAgZGVidWcoJ0NyZWF0aW5nIG5ldyBIdHRwc1Byb3h5QWdlbnQgaW5zdGFuY2U6ICVvJywgdGhpcy5wcm94eS5ocmVmKTtcbiAgICAgICAgLy8gVHJpbSBvZmYgdGhlIGJyYWNrZXRzIGZyb20gSVB2NiBhZGRyZXNzZXNcbiAgICAgICAgY29uc3QgaG9zdCA9ICh0aGlzLnByb3h5Lmhvc3RuYW1lIHx8IHRoaXMucHJveHkuaG9zdCkucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgY29uc3QgcG9ydCA9IHRoaXMucHJveHkucG9ydFxuICAgICAgICAgICAgPyBwYXJzZUludCh0aGlzLnByb3h5LnBvcnQsIDEwKVxuICAgICAgICAgICAgOiB0aGlzLnByb3h5LnByb3RvY29sID09PSAnaHR0cHM6J1xuICAgICAgICAgICAgICAgID8gNDQzXG4gICAgICAgICAgICAgICAgOiA4MDtcbiAgICAgICAgdGhpcy5jb25uZWN0T3B0cyA9IHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gbmVnb3RpYXRlIGh0dHAvMS4xIGZvciBwcm94eSBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBodHRwLzJcbiAgICAgICAgICAgIEFMUE5Qcm90b2NvbHM6IFsnaHR0cC8xLjEnXSxcbiAgICAgICAgICAgIC4uLihvcHRzID8gb21pdChvcHRzLCAnaGVhZGVycycpIDogbnVsbCksXG4gICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG5vZGUtY29yZSBIVFRQIGNsaWVudCBsaWJyYXJ5IGlzIGNyZWF0aW5nIGFcbiAgICAgKiBuZXcgSFRUUCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QocmVxLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJveHkgfSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0cy5ob3N0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBcImhvc3RcIiBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIHNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIuXG4gICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgIGlmIChwcm94eS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGRlYnVnKCdDcmVhdGluZyBgdGxzLlNvY2tldGA6ICVvJywgdGhpcy5jb25uZWN0T3B0cyk7XG4gICAgICAgICAgICBzb2NrZXQgPSB0bHMuY29ubmVjdChzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdCh0aGlzLmNvbm5lY3RPcHRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgYG5ldC5Tb2NrZXRgOiAlbycsIHRoaXMuY29ubmVjdE9wdHMpO1xuICAgICAgICAgICAgc29ja2V0ID0gbmV0LmNvbm5lY3QodGhpcy5jb25uZWN0T3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHR5cGVvZiB0aGlzLnByb3h5SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyB0aGlzLnByb3h5SGVhZGVycygpXG4gICAgICAgICAgICA6IHsgLi4udGhpcy5wcm94eUhlYWRlcnMgfTtcbiAgICAgICAgY29uc3QgaG9zdCA9IG5ldC5pc0lQdjYob3B0cy5ob3N0KSA/IGBbJHtvcHRzLmhvc3R9XWAgOiBvcHRzLmhvc3Q7XG4gICAgICAgIGxldCBwYXlsb2FkID0gYENPTk5FQ1QgJHtob3N0fToke29wdHMucG9ydH0gSFRUUC8xLjFcXHJcXG5gO1xuICAgICAgICAvLyBJbmplY3QgdGhlIGBQcm94eS1BdXRob3JpemF0aW9uYCBoZWFkZXIgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAocHJveHkudXNlcm5hbWUgfHwgcHJveHkucGFzc3dvcmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGF1dGggPSBgJHtkZWNvZGVVUklDb21wb25lbnQocHJveHkudXNlcm5hbWUpfToke2RlY29kZVVSSUNvbXBvbmVudChwcm94eS5wYXNzd29yZCl9YDtcbiAgICAgICAgICAgIGhlYWRlcnNbJ1Byb3h5LUF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke0J1ZmZlci5mcm9tKGF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKX1gO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnMuSG9zdCA9IGAke2hvc3R9OiR7b3B0cy5wb3J0fWA7XG4gICAgICAgIGlmICghaGVhZGVyc1snUHJveHktQ29ubmVjdGlvbiddKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydQcm94eS1Db25uZWN0aW9uJ10gPSB0aGlzLmtlZXBBbGl2ZVxuICAgICAgICAgICAgICAgID8gJ0tlZXAtQWxpdmUnXG4gICAgICAgICAgICAgICAgOiAnY2xvc2UnO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgcGF5bG9hZCArPSBgJHtuYW1lfTogJHtoZWFkZXJzW25hbWVdfVxcclxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJveHlSZXNwb25zZVByb21pc2UgPSAoMCwgcGFyc2VfcHJveHlfcmVzcG9uc2VfMS5wYXJzZVByb3h5UmVzcG9uc2UpKHNvY2tldCk7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtwYXlsb2FkfVxcclxcbmApO1xuICAgICAgICBjb25zdCB7IGNvbm5lY3QsIGJ1ZmZlcmVkIH0gPSBhd2FpdCBwcm94eVJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgcmVxLmVtaXQoJ3Byb3h5Q29ubmVjdCcsIGNvbm5lY3QpO1xuICAgICAgICB0aGlzLmVtaXQoJ3Byb3h5Q29ubmVjdCcsIGNvbm5lY3QsIHJlcSk7XG4gICAgICAgIGlmIChjb25uZWN0LnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVxLm9uY2UoJ3NvY2tldCcsIHJlc3VtZSk7XG4gICAgICAgICAgICBpZiAob3B0cy5zZWN1cmVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcm94eSBpcyBjb25uZWN0aW5nIHRvIGEgVExTIHNlcnZlciwgc28gdXBncmFkZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc29ja2V0IGNvbm5lY3Rpb24gdG8gYSBUTFMgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICBkZWJ1ZygnVXBncmFkaW5nIHNvY2tldCBjb25uZWN0aW9uIHRvIFRMUycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0bHMuY29ubmVjdCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9taXQoc2V0U2VydmVybmFtZUZyb21Ob25JcEhvc3Qob3B0cyksICdob3N0JywgJ3BhdGgnLCAncG9ydCcpLFxuICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgb3RoZXIgc3RhdHVzIGNvZGUgdGhhdCdzIG5vdCAyMDAuLi4gbmVlZCB0byByZS1wbGF5IHRoZSBIVFRQXG4gICAgICAgIC8vIGhlYWRlciBcImRhdGFcIiBldmVudHMgb250byB0aGUgc29ja2V0IG9uY2UgdGhlIEhUVFAgbWFjaGluZXJ5IGlzXG4gICAgICAgIC8vIGF0dGFjaGVkIHNvIHRoYXQgdGhlIG5vZGUgY29yZSBgaHR0cGAgY2FuIHBhcnNlIGFuZCBoYW5kbGUgdGhlXG4gICAgICAgIC8vIGVycm9yIHN0YXR1cyBjb2RlLlxuICAgICAgICAvLyBDbG9zZSB0aGUgb3JpZ2luYWwgc29ja2V0LCBhbmQgYSBuZXcgXCJmYWtlXCIgc29ja2V0IGlzIHJldHVybmVkXG4gICAgICAgIC8vIGluc3RlYWQsIHNvIHRoYXQgdGhlIHByb3h5IGRvZXNuJ3QgZ2V0IHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgICAgLy8gd3JpdHRlbiB0byBpdCAod2hpY2ggbWF5IGNvbnRhaW4gYEF1dGhvcml6YXRpb25gIGhlYWRlcnMgb3Igb3RoZXJcbiAgICAgICAgLy8gc2Vuc2l0aXZlIGRhdGEpLlxuICAgICAgICAvL1xuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vaGFja2Vyb25lLmNvbS9yZXBvcnRzLzU0MTUwMlxuICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICBjb25zdCBmYWtlU29ja2V0ID0gbmV3IG5ldC5Tb2NrZXQoeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgICAgIGZha2VTb2NrZXQucmVhZGFibGUgPSB0cnVlO1xuICAgICAgICAvLyBOZWVkIHRvIHdhaXQgZm9yIHRoZSBcInNvY2tldFwiIGV2ZW50IHRvIHJlLXBsYXkgdGhlIFwiZGF0YVwiIGV2ZW50cy5cbiAgICAgICAgcmVxLm9uY2UoJ3NvY2tldCcsIChzKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZygnUmVwbGF5aW5nIHByb3h5IGJ1ZmZlciBmb3IgZmFpbGVkIHJlcXVlc3QnKTtcbiAgICAgICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApO1xuICAgICAgICAgICAgLy8gUmVwbGF5IHRoZSBcImJ1ZmZlcmVkXCIgQnVmZmVyIG9udG8gdGhlIGZha2UgYHNvY2tldGAsIHNpbmNlIGF0XG4gICAgICAgICAgICAvLyB0aGlzIHBvaW50IHRoZSBIVFRQIG1vZHVsZSBtYWNoaW5lcnkgaGFzIGJlZW4gaG9va2VkIHVwIGZvclxuICAgICAgICAgICAgLy8gdGhlIHVzZXIuXG4gICAgICAgICAgICBzLnB1c2goYnVmZmVyZWQpO1xuICAgICAgICAgICAgcy5wdXNoKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZha2VTb2NrZXQ7XG4gICAgfVxufVxuSHR0cHNQcm94eUFnZW50LnByb3RvY29scyA9IFsnaHR0cCcsICdodHRwcyddO1xuZXhwb3J0cy5IdHRwc1Byb3h5QWdlbnQgPSBIdHRwc1Byb3h5QWdlbnQ7XG5mdW5jdGlvbiByZXN1bWUoc29ja2V0KSB7XG4gICAgc29ja2V0LnJlc3VtZSgpO1xufVxuZnVuY3Rpb24gb21pdChvYmosIC4uLmtleXMpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQga2V5O1xuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9faW1wb3J0RGVmYXVsdCIsImV4cG9ydHMiLCJIdHRwc1Byb3h5QWdlbnQiLCJuZXQiLCJyZXF1aXJlIiwidGxzIiwiYXNzZXJ0XzEiLCJkZWJ1Z18xIiwiYWdlbnRfYmFzZV8xIiwidXJsXzEiLCJwYXJzZV9wcm94eV9yZXNwb25zZV8xIiwiZGVidWciLCJkZWZhdWx0Iiwic2V0U2VydmVybmFtZUZyb21Ob25JcEhvc3QiLCJvcHRpb25zIiwic2VydmVybmFtZSIsImhvc3QiLCJpc0lQIiwiQWdlbnQiLCJjb25zdHJ1Y3RvciIsInByb3h5Iiwib3B0cyIsInBhdGgiLCJVUkwiLCJwcm94eUhlYWRlcnMiLCJoZWFkZXJzIiwiaHJlZiIsImhvc3RuYW1lIiwicmVwbGFjZSIsInBvcnQiLCJwYXJzZUludCIsInByb3RvY29sIiwiY29ubmVjdE9wdHMiLCJBTFBOUHJvdG9jb2xzIiwib21pdCIsImNvbm5lY3QiLCJyZXEiLCJUeXBlRXJyb3IiLCJzb2NrZXQiLCJpc0lQdjYiLCJwYXlsb2FkIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImF1dGgiLCJkZWNvZGVVUklDb21wb25lbnQiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJIb3N0Iiwia2VlcEFsaXZlIiwibmFtZSIsImtleXMiLCJwcm94eVJlc3BvbnNlUHJvbWlzZSIsInBhcnNlUHJveHlSZXNwb25zZSIsIndyaXRlIiwiYnVmZmVyZWQiLCJlbWl0Iiwic3RhdHVzQ29kZSIsIm9uY2UiLCJyZXN1bWUiLCJzZWN1cmVFbmRwb2ludCIsImRlc3Ryb3kiLCJmYWtlU29ja2V0IiwiU29ja2V0IiwicmVhZGFibGUiLCJzIiwibGlzdGVuZXJDb3VudCIsInB1c2giLCJwcm90b2NvbHMiLCJvYmoiLCJyZXQiLCJrZXkiLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/https-proxy-agent/dist/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!*********************************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseProxyResponse = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(action-browser)/./node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"https-proxy-agent:parse-proxy-response\");\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject)=>{\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b) ondata(b);\n            else socket.once(\"readable\", read);\n        }\n        function cleanup() {\n            socket.removeListener(\"end\", onend);\n            socket.removeListener(\"error\", onerror);\n            socket.removeListener(\"readable\", read);\n        }\n        function onend() {\n            cleanup();\n            debug(\"onend\");\n            reject(new Error(\"Proxy connection ended before receiving CONNECT response\"));\n        }\n        function onerror(err) {\n            cleanup();\n            debug(\"onerror %o\", err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf(\"\\r\\n\\r\\n\");\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug(\"have not received end of HTTP headers yet...\");\n                read();\n                return;\n            }\n            const headerParts = buffered.slice(0, endOfHeaders).toString(\"ascii\").split(\"\\r\\n\");\n            const firstLine = headerParts.shift();\n            if (!firstLine) {\n                socket.destroy();\n                return reject(new Error(\"No header received from proxy CONNECT response\"));\n            }\n            const firstLineParts = firstLine.split(\" \");\n            const statusCode = +firstLineParts[1];\n            const statusText = firstLineParts.slice(2).join(\" \");\n            const headers = {};\n            for (const header of headerParts){\n                if (!header) continue;\n                const firstColon = header.indexOf(\":\");\n                if (firstColon === -1) {\n                    socket.destroy();\n                    return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\n                }\n                const key = header.slice(0, firstColon).toLowerCase();\n                const value = header.slice(firstColon + 1).trimStart();\n                const current = headers[key];\n                if (typeof current === \"string\") {\n                    headers[key] = [\n                        current,\n                        value\n                    ];\n                } else if (Array.isArray(current)) {\n                    current.push(value);\n                } else {\n                    headers[key] = value;\n                }\n            }\n            debug(\"got proxy server response: %o %o\", firstLine, headers);\n            cleanup();\n            resolve({\n                connect: {\n                    statusCode,\n                    statusText,\n                    headers\n                },\n                buffered\n            });\n        }\n        socket.on(\"error\", onerror);\n        socket.on(\"end\", onend);\n        read();\n    });\n}\nexports.parseProxyResponse = parseProxyResponse; //# sourceMappingURL=parse-proxy-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L3BhcnNlLXByb3h5LXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBRyxLQUFLO0FBQ2xDLE1BQU1HLFVBQVVSLGdCQUFnQlMsbUJBQU9BLENBQUMsaUVBQU87QUFDL0MsTUFBTUMsUUFBUSxDQUFDLEdBQUdGLFFBQVFHLE9BQU8sRUFBRTtBQUNuQyxTQUFTSixtQkFBbUJLLE1BQU07SUFDOUIsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQ3pCLCtFQUErRTtRQUMvRSxnRkFBZ0Y7UUFDaEYsOEVBQThFO1FBQzlFLDhCQUE4QjtRQUM5QixJQUFJQyxnQkFBZ0I7UUFDcEIsTUFBTUMsVUFBVSxFQUFFO1FBQ2xCLFNBQVNDO1lBQ0wsTUFBTUMsSUFBSVAsT0FBT00sSUFBSTtZQUNyQixJQUFJQyxHQUNBQyxPQUFPRDtpQkFFUFAsT0FBT1MsSUFBSSxDQUFDLFlBQVlIO1FBQ2hDO1FBQ0EsU0FBU0k7WUFDTFYsT0FBT1csY0FBYyxDQUFDLE9BQU9DO1lBQzdCWixPQUFPVyxjQUFjLENBQUMsU0FBU0U7WUFDL0JiLE9BQU9XLGNBQWMsQ0FBQyxZQUFZTDtRQUN0QztRQUNBLFNBQVNNO1lBQ0xGO1lBQ0FaLE1BQU07WUFDTkssT0FBTyxJQUFJVyxNQUFNO1FBQ3JCO1FBQ0EsU0FBU0QsUUFBUUUsR0FBRztZQUNoQkw7WUFDQVosTUFBTSxjQUFjaUI7WUFDcEJaLE9BQU9ZO1FBQ1g7UUFDQSxTQUFTUCxPQUFPRCxDQUFDO1lBQ2JGLFFBQVFXLElBQUksQ0FBQ1Q7WUFDYkgsaUJBQWlCRyxFQUFFVSxNQUFNO1lBQ3pCLE1BQU1DLFdBQVdDLE9BQU9DLE1BQU0sQ0FBQ2YsU0FBU0Q7WUFDeEMsTUFBTWlCLGVBQWVILFNBQVNJLE9BQU8sQ0FBQztZQUN0QyxJQUFJRCxpQkFBaUIsQ0FBQyxHQUFHO2dCQUNyQixpQkFBaUI7Z0JBQ2pCdkIsTUFBTTtnQkFDTlE7Z0JBQ0E7WUFDSjtZQUNBLE1BQU1pQixjQUFjTCxTQUNmTSxLQUFLLENBQUMsR0FBR0gsY0FDVEksUUFBUSxDQUFDLFNBQ1RDLEtBQUssQ0FBQztZQUNYLE1BQU1DLFlBQVlKLFlBQVlLLEtBQUs7WUFDbkMsSUFBSSxDQUFDRCxXQUFXO2dCQUNaM0IsT0FBTzZCLE9BQU87Z0JBQ2QsT0FBTzFCLE9BQU8sSUFBSVcsTUFBTTtZQUM1QjtZQUNBLE1BQU1nQixpQkFBaUJILFVBQVVELEtBQUssQ0FBQztZQUN2QyxNQUFNSyxhQUFhLENBQUNELGNBQWMsQ0FBQyxFQUFFO1lBQ3JDLE1BQU1FLGFBQWFGLGVBQWVOLEtBQUssQ0FBQyxHQUFHUyxJQUFJLENBQUM7WUFDaEQsTUFBTUMsVUFBVSxDQUFDO1lBQ2pCLEtBQUssTUFBTUMsVUFBVVosWUFBYTtnQkFDOUIsSUFBSSxDQUFDWSxRQUNEO2dCQUNKLE1BQU1DLGFBQWFELE9BQU9iLE9BQU8sQ0FBQztnQkFDbEMsSUFBSWMsZUFBZSxDQUFDLEdBQUc7b0JBQ25CcEMsT0FBTzZCLE9BQU87b0JBQ2QsT0FBTzFCLE9BQU8sSUFBSVcsTUFBTSxDQUFDLDZDQUE2QyxFQUFFcUIsT0FBTyxDQUFDLENBQUM7Z0JBQ3JGO2dCQUNBLE1BQU1FLE1BQU1GLE9BQU9YLEtBQUssQ0FBQyxHQUFHWSxZQUFZRSxXQUFXO2dCQUNuRCxNQUFNNUMsUUFBUXlDLE9BQU9YLEtBQUssQ0FBQ1ksYUFBYSxHQUFHRyxTQUFTO2dCQUNwRCxNQUFNQyxVQUFVTixPQUFPLENBQUNHLElBQUk7Z0JBQzVCLElBQUksT0FBT0csWUFBWSxVQUFVO29CQUM3Qk4sT0FBTyxDQUFDRyxJQUFJLEdBQUc7d0JBQUNHO3dCQUFTOUM7cUJBQU07Z0JBQ25DLE9BQ0ssSUFBSStDLE1BQU1DLE9BQU8sQ0FBQ0YsVUFBVTtvQkFDN0JBLFFBQVF4QixJQUFJLENBQUN0QjtnQkFDakIsT0FDSztvQkFDRHdDLE9BQU8sQ0FBQ0csSUFBSSxHQUFHM0M7Z0JBQ25CO1lBQ0o7WUFDQUksTUFBTSxvQ0FBb0M2QixXQUFXTztZQUNyRHhCO1lBQ0FSLFFBQVE7Z0JBQ0p5QyxTQUFTO29CQUNMWjtvQkFDQUM7b0JBQ0FFO2dCQUNKO2dCQUNBaEI7WUFDSjtRQUNKO1FBQ0FsQixPQUFPNEMsRUFBRSxDQUFDLFNBQVMvQjtRQUNuQmIsT0FBTzRDLEVBQUUsQ0FBQyxPQUFPaEM7UUFDakJOO0lBQ0o7QUFDSjtBQUNBYiwwQkFBMEIsR0FBR0Usb0JBQzdCLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2F6dXJlLW9wZW4tYWktYWNjZWxlcmF0b3IvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9wYXJzZS1wcm94eS1yZXNwb25zZS5qcz9jZDM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZVByb3h5UmVzcG9uc2UgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdodHRwcy1wcm94eS1hZ2VudDpwYXJzZS1wcm94eS1yZXNwb25zZScpO1xuZnVuY3Rpb24gcGFyc2VQcm94eVJlc3BvbnNlKHNvY2tldCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gYnVmZmVyIGFueSBIVFRQIHRyYWZmaWMgdGhhdCBoYXBwZW5zIHdpdGggdGhlIHByb3h5IGJlZm9yZSB3ZSBnZXRcbiAgICAgICAgLy8gdGhlIENPTk5FQ1QgcmVzcG9uc2UsIHNvIHRoYXQgaWYgdGhlIHJlc3BvbnNlIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gYW4gXCIyMDBcIlxuICAgICAgICAvLyByZXNwb25zZSBjb2RlLCB0aGVuIHdlIGNhbiByZS1wbGF5IHRoZSBcImRhdGFcIiBldmVudHMgb24gdGhlIHNvY2tldCBvbmNlIHRoZVxuICAgICAgICAvLyBIVFRQIHBhcnNlciBpcyBob29rZWQgdXAuLi5cbiAgICAgICAgbGV0IGJ1ZmZlcnNMZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgICAgICBjb25zdCBiID0gc29ja2V0LnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgIG9uZGF0YShiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzb2NrZXQub25jZSgncmVhZGFibGUnLCByZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1Byb3h5IGNvbm5lY3Rpb24gZW5kZWQgYmVmb3JlIHJlY2VpdmluZyBDT05ORUNUIHJlc3BvbnNlJykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBkZWJ1Zygnb25lcnJvciAlbycsIGVycik7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmRhdGEoYikge1xuICAgICAgICAgICAgYnVmZmVycy5wdXNoKGIpO1xuICAgICAgICAgICAgYnVmZmVyc0xlbmd0aCArPSBiLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBidWZmZXJzTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZE9mSGVhZGVycyA9IGJ1ZmZlcmVkLmluZGV4T2YoJ1xcclxcblxcclxcbicpO1xuICAgICAgICAgICAgaWYgKGVuZE9mSGVhZGVycyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBrZWVwIGJ1ZmZlcmluZ1xuICAgICAgICAgICAgICAgIGRlYnVnKCdoYXZlIG5vdCByZWNlaXZlZCBlbmQgb2YgSFRUUCBoZWFkZXJzIHlldC4uLicpO1xuICAgICAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJ0cyA9IGJ1ZmZlcmVkXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIGVuZE9mSGVhZGVycylcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2FzY2lpJylcbiAgICAgICAgICAgICAgICAuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gaGVhZGVyUGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghZmlyc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gaGVhZGVyIHJlY2VpdmVkIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZVBhcnRzID0gZmlyc3RMaW5lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gK2ZpcnN0TGluZVBhcnRzWzFdO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzVGV4dCA9IGZpcnN0TGluZVBhcnRzLnNsaWNlKDIpLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIGhlYWRlclBhcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29sb24gPSBoZWFkZXIuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdENvbG9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgSW52YWxpZCBoZWFkZXIgZnJvbSBwcm94eSBDT05ORUNUIHJlc3BvbnNlOiBcIiR7aGVhZGVyfVwiYCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBoZWFkZXIuc2xpY2UoMCwgZmlyc3RDb2xvbikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5zbGljZShmaXJzdENvbG9uICsgMSkudHJpbVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IFtjdXJyZW50LCB2YWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnKCdnb3QgcHJveHkgc2VydmVyIHJlc3BvbnNlOiAlbyAlbycsIGZpcnN0TGluZSwgaGVhZGVycyk7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBjb25uZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBidWZmZXJlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNvY2tldC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgICAgICAgc29ja2V0Lm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgIHJlYWQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucGFyc2VQcm94eVJlc3BvbnNlID0gcGFyc2VQcm94eVJlc3BvbnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtcHJveHktcmVzcG9uc2UuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlUHJveHlSZXNwb25zZSIsImRlYnVnXzEiLCJyZXF1aXJlIiwiZGVidWciLCJkZWZhdWx0Iiwic29ja2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJidWZmZXJzTGVuZ3RoIiwiYnVmZmVycyIsInJlYWQiLCJiIiwib25kYXRhIiwib25jZSIsImNsZWFudXAiLCJyZW1vdmVMaXN0ZW5lciIsIm9uZW5kIiwib25lcnJvciIsIkVycm9yIiwiZXJyIiwicHVzaCIsImxlbmd0aCIsImJ1ZmZlcmVkIiwiQnVmZmVyIiwiY29uY2F0IiwiZW5kT2ZIZWFkZXJzIiwiaW5kZXhPZiIsImhlYWRlclBhcnRzIiwic2xpY2UiLCJ0b1N0cmluZyIsInNwbGl0IiwiZmlyc3RMaW5lIiwic2hpZnQiLCJkZXN0cm95IiwiZmlyc3RMaW5lUGFydHMiLCJzdGF0dXNDb2RlIiwic3RhdHVzVGV4dCIsImpvaW4iLCJoZWFkZXJzIiwiaGVhZGVyIiwiZmlyc3RDb2xvbiIsImtleSIsInRvTG93ZXJDYXNlIiwidHJpbVN0YXJ0IiwiY3VycmVudCIsIkFycmF5IiwiaXNBcnJheSIsImNvbm5lY3QiLCJvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!*********************************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseProxyResponse = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"https-proxy-agent:parse-proxy-response\");\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject)=>{\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b) ondata(b);\n            else socket.once(\"readable\", read);\n        }\n        function cleanup() {\n            socket.removeListener(\"end\", onend);\n            socket.removeListener(\"error\", onerror);\n            socket.removeListener(\"readable\", read);\n        }\n        function onend() {\n            cleanup();\n            debug(\"onend\");\n            reject(new Error(\"Proxy connection ended before receiving CONNECT response\"));\n        }\n        function onerror(err) {\n            cleanup();\n            debug(\"onerror %o\", err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf(\"\\r\\n\\r\\n\");\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug(\"have not received end of HTTP headers yet...\");\n                read();\n                return;\n            }\n            const headerParts = buffered.slice(0, endOfHeaders).toString(\"ascii\").split(\"\\r\\n\");\n            const firstLine = headerParts.shift();\n            if (!firstLine) {\n                socket.destroy();\n                return reject(new Error(\"No header received from proxy CONNECT response\"));\n            }\n            const firstLineParts = firstLine.split(\" \");\n            const statusCode = +firstLineParts[1];\n            const statusText = firstLineParts.slice(2).join(\" \");\n            const headers = {};\n            for (const header of headerParts){\n                if (!header) continue;\n                const firstColon = header.indexOf(\":\");\n                if (firstColon === -1) {\n                    socket.destroy();\n                    return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\n                }\n                const key = header.slice(0, firstColon).toLowerCase();\n                const value = header.slice(firstColon + 1).trimStart();\n                const current = headers[key];\n                if (typeof current === \"string\") {\n                    headers[key] = [\n                        current,\n                        value\n                    ];\n                } else if (Array.isArray(current)) {\n                    current.push(value);\n                } else {\n                    headers[key] = value;\n                }\n            }\n            debug(\"got proxy server response: %o %o\", firstLine, headers);\n            cleanup();\n            resolve({\n                connect: {\n                    statusCode,\n                    statusText,\n                    headers\n                },\n                buffered\n            });\n        }\n        socket.on(\"error\", onerror);\n        socket.on(\"end\", onend);\n        read();\n    });\n}\nexports.parseProxyResponse = parseProxyResponse; //# sourceMappingURL=parse-proxy-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9wYXJzZS1wcm94eS1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQyxNQUFNRyxVQUFVUixnQkFBZ0JTLG1CQUFPQSxDQUFDLHNEQUFPO0FBQy9DLE1BQU1DLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxPQUFPLEVBQUU7QUFDbkMsU0FBU0osbUJBQW1CSyxNQUFNO0lBQzlCLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUN6QiwrRUFBK0U7UUFDL0UsZ0ZBQWdGO1FBQ2hGLDhFQUE4RTtRQUM5RSw4QkFBOEI7UUFDOUIsSUFBSUMsZ0JBQWdCO1FBQ3BCLE1BQU1DLFVBQVUsRUFBRTtRQUNsQixTQUFTQztZQUNMLE1BQU1DLElBQUlQLE9BQU9NLElBQUk7WUFDckIsSUFBSUMsR0FDQUMsT0FBT0Q7aUJBRVBQLE9BQU9TLElBQUksQ0FBQyxZQUFZSDtRQUNoQztRQUNBLFNBQVNJO1lBQ0xWLE9BQU9XLGNBQWMsQ0FBQyxPQUFPQztZQUM3QlosT0FBT1csY0FBYyxDQUFDLFNBQVNFO1lBQy9CYixPQUFPVyxjQUFjLENBQUMsWUFBWUw7UUFDdEM7UUFDQSxTQUFTTTtZQUNMRjtZQUNBWixNQUFNO1lBQ05LLE9BQU8sSUFBSVcsTUFBTTtRQUNyQjtRQUNBLFNBQVNELFFBQVFFLEdBQUc7WUFDaEJMO1lBQ0FaLE1BQU0sY0FBY2lCO1lBQ3BCWixPQUFPWTtRQUNYO1FBQ0EsU0FBU1AsT0FBT0QsQ0FBQztZQUNiRixRQUFRVyxJQUFJLENBQUNUO1lBQ2JILGlCQUFpQkcsRUFBRVUsTUFBTTtZQUN6QixNQUFNQyxXQUFXQyxPQUFPQyxNQUFNLENBQUNmLFNBQVNEO1lBQ3hDLE1BQU1pQixlQUFlSCxTQUFTSSxPQUFPLENBQUM7WUFDdEMsSUFBSUQsaUJBQWlCLENBQUMsR0FBRztnQkFDckIsaUJBQWlCO2dCQUNqQnZCLE1BQU07Z0JBQ05RO2dCQUNBO1lBQ0o7WUFDQSxNQUFNaUIsY0FBY0wsU0FDZk0sS0FBSyxDQUFDLEdBQUdILGNBQ1RJLFFBQVEsQ0FBQyxTQUNUQyxLQUFLLENBQUM7WUFDWCxNQUFNQyxZQUFZSixZQUFZSyxLQUFLO1lBQ25DLElBQUksQ0FBQ0QsV0FBVztnQkFDWjNCLE9BQU82QixPQUFPO2dCQUNkLE9BQU8xQixPQUFPLElBQUlXLE1BQU07WUFDNUI7WUFDQSxNQUFNZ0IsaUJBQWlCSCxVQUFVRCxLQUFLLENBQUM7WUFDdkMsTUFBTUssYUFBYSxDQUFDRCxjQUFjLENBQUMsRUFBRTtZQUNyQyxNQUFNRSxhQUFhRixlQUFlTixLQUFLLENBQUMsR0FBR1MsSUFBSSxDQUFDO1lBQ2hELE1BQU1DLFVBQVUsQ0FBQztZQUNqQixLQUFLLE1BQU1DLFVBQVVaLFlBQWE7Z0JBQzlCLElBQUksQ0FBQ1ksUUFDRDtnQkFDSixNQUFNQyxhQUFhRCxPQUFPYixPQUFPLENBQUM7Z0JBQ2xDLElBQUljLGVBQWUsQ0FBQyxHQUFHO29CQUNuQnBDLE9BQU82QixPQUFPO29CQUNkLE9BQU8xQixPQUFPLElBQUlXLE1BQU0sQ0FBQyw2Q0FBNkMsRUFBRXFCLE9BQU8sQ0FBQyxDQUFDO2dCQUNyRjtnQkFDQSxNQUFNRSxNQUFNRixPQUFPWCxLQUFLLENBQUMsR0FBR1ksWUFBWUUsV0FBVztnQkFDbkQsTUFBTTVDLFFBQVF5QyxPQUFPWCxLQUFLLENBQUNZLGFBQWEsR0FBR0csU0FBUztnQkFDcEQsTUFBTUMsVUFBVU4sT0FBTyxDQUFDRyxJQUFJO2dCQUM1QixJQUFJLE9BQU9HLFlBQVksVUFBVTtvQkFDN0JOLE9BQU8sQ0FBQ0csSUFBSSxHQUFHO3dCQUFDRzt3QkFBUzlDO3FCQUFNO2dCQUNuQyxPQUNLLElBQUkrQyxNQUFNQyxPQUFPLENBQUNGLFVBQVU7b0JBQzdCQSxRQUFReEIsSUFBSSxDQUFDdEI7Z0JBQ2pCLE9BQ0s7b0JBQ0R3QyxPQUFPLENBQUNHLElBQUksR0FBRzNDO2dCQUNuQjtZQUNKO1lBQ0FJLE1BQU0sb0NBQW9DNkIsV0FBV087WUFDckR4QjtZQUNBUixRQUFRO2dCQUNKeUMsU0FBUztvQkFDTFo7b0JBQ0FDO29CQUNBRTtnQkFDSjtnQkFDQWhCO1lBQ0o7UUFDSjtRQUNBbEIsT0FBTzRDLEVBQUUsQ0FBQyxTQUFTL0I7UUFDbkJiLE9BQU80QyxFQUFFLENBQUMsT0FBT2hDO1FBQ2pCTjtJQUNKO0FBQ0o7QUFDQWIsMEJBQTBCLEdBQUdFLG9CQUM3QixnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9henVyZS1vcGVuLWFpLWFjY2VsZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L2Rpc3QvcGFyc2UtcHJveHktcmVzcG9uc2UuanM/Y2QzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VQcm94eVJlc3BvbnNlID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnaHR0cHMtcHJveHktYWdlbnQ6cGFyc2UtcHJveHktcmVzcG9uc2UnKTtcbmZ1bmN0aW9uIHBhcnNlUHJveHlSZXNwb25zZShzb2NrZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGJ1ZmZlciBhbnkgSFRUUCB0cmFmZmljIHRoYXQgaGFwcGVucyB3aXRoIHRoZSBwcm94eSBiZWZvcmUgd2UgZ2V0XG4gICAgICAgIC8vIHRoZSBDT05ORUNUIHJlc3BvbnNlLCBzbyB0aGF0IGlmIHRoZSByZXNwb25zZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGFuIFwiMjAwXCJcbiAgICAgICAgLy8gcmVzcG9uc2UgY29kZSwgdGhlbiB3ZSBjYW4gcmUtcGxheSB0aGUgXCJkYXRhXCIgZXZlbnRzIG9uIHRoZSBzb2NrZXQgb25jZSB0aGVcbiAgICAgICAgLy8gSFRUUCBwYXJzZXIgaXMgaG9va2VkIHVwLi4uXG4gICAgICAgIGxldCBidWZmZXJzTGVuZ3RoID0gMDtcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICAgICAgY29uc3QgYiA9IHNvY2tldC5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICBvbmRhdGEoYik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uY2UoJ3JlYWRhYmxlJywgcmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHJlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgZGVidWcoJ29uZW5kJyk7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdQcm94eSBjb25uZWN0aW9uIGVuZGVkIGJlZm9yZSByZWNlaXZpbmcgQ09OTkVDVCByZXNwb25zZScpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgZGVidWcoJ29uZXJyb3IgJW8nLCBlcnIpO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25kYXRhKGIpIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChiKTtcbiAgICAgICAgICAgIGJ1ZmZlcnNMZW5ndGggKz0gYi5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgYnVmZmVyc0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBlbmRPZkhlYWRlcnMgPSBidWZmZXJlZC5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgICAgIGlmIChlbmRPZkhlYWRlcnMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBidWZmZXJpbmdcbiAgICAgICAgICAgICAgICBkZWJ1ZygnaGF2ZSBub3QgcmVjZWl2ZWQgZW5kIG9mIEhUVFAgaGVhZGVycyB5ZXQuLi4nKTtcbiAgICAgICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFydHMgPSBidWZmZXJlZFxuICAgICAgICAgICAgICAgIC5zbGljZSgwLCBlbmRPZkhlYWRlcnMpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKCdhc2NpaScpXG4gICAgICAgICAgICAgICAgLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IGhlYWRlclBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWZpcnN0TGluZSkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIGhlYWRlciByZWNlaXZlZCBmcm9tIHByb3h5IENPTk5FQ1QgcmVzcG9uc2UnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaXJzdExpbmVQYXJ0cyA9IGZpcnN0TGluZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9ICtmaXJzdExpbmVQYXJ0c1sxXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c1RleHQgPSBmaXJzdExpbmVQYXJ0cy5zbGljZSgyKS5qb2luKCcgJyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJQYXJ0cykge1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVyKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdENvbG9uID0gaGVhZGVyLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RDb2xvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYEludmFsaWQgaGVhZGVyIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZTogXCIke2hlYWRlcn1cImApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyLnNsaWNlKDAsIGZpcnN0Q29sb24pLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXIuc2xpY2UoZmlyc3RDb2xvbiArIDEpLnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBoZWFkZXJzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSBbY3VycmVudCwgdmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZygnZ290IHByb3h5IHNlcnZlciByZXNwb25zZTogJW8gJW8nLCBmaXJzdExpbmUsIGhlYWRlcnMpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgY29ubmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYnVmZmVyZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICAgIHNvY2tldC5vbignZW5kJywgb25lbmQpO1xuICAgICAgICByZWFkKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLnBhcnNlUHJveHlSZXNwb25zZSA9IHBhcnNlUHJveHlSZXNwb25zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXByb3h5LXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYXJzZVByb3h5UmVzcG9uc2UiLCJkZWJ1Z18xIiwicmVxdWlyZSIsImRlYnVnIiwiZGVmYXVsdCIsInNvY2tldCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYnVmZmVyc0xlbmd0aCIsImJ1ZmZlcnMiLCJyZWFkIiwiYiIsIm9uZGF0YSIsIm9uY2UiLCJjbGVhbnVwIiwicmVtb3ZlTGlzdGVuZXIiLCJvbmVuZCIsIm9uZXJyb3IiLCJFcnJvciIsImVyciIsInB1c2giLCJsZW5ndGgiLCJidWZmZXJlZCIsIkJ1ZmZlciIsImNvbmNhdCIsImVuZE9mSGVhZGVycyIsImluZGV4T2YiLCJoZWFkZXJQYXJ0cyIsInNsaWNlIiwidG9TdHJpbmciLCJzcGxpdCIsImZpcnN0TGluZSIsInNoaWZ0IiwiZGVzdHJveSIsImZpcnN0TGluZVBhcnRzIiwic3RhdHVzQ29kZSIsInN0YXR1c1RleHQiLCJqb2luIiwiaGVhZGVycyIsImhlYWRlciIsImZpcnN0Q29sb24iLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsInRyaW1TdGFydCIsImN1cnJlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJjb25uZWN0Iiwib24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/helpers.js":
/*!********************************************************************************!*\
  !*** ./node_modules/https-proxy-agent/node_modules/agent-base/dist/helpers.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.req = exports.json = exports.toBuffer = void 0;\nconst http = __importStar(__webpack_require__(/*! http */ \"http\"));\nconst https = __importStar(__webpack_require__(/*! https */ \"https\"));\nasync function toBuffer(stream) {\n    let length = 0;\n    const chunks = [];\n    for await (const chunk of stream){\n        length += chunk.length;\n        chunks.push(chunk);\n    }\n    return Buffer.concat(chunks, length);\n}\nexports.toBuffer = toBuffer;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function json(stream) {\n    const buf = await toBuffer(stream);\n    const str = buf.toString(\"utf8\");\n    try {\n        return JSON.parse(str);\n    } catch (_err) {\n        const err = _err;\n        err.message += ` (input: ${str})`;\n        throw err;\n    }\n}\nexports.json = json;\nfunction req(url, opts = {}) {\n    const href = typeof url === \"string\" ? url : url.href;\n    const req = (href.startsWith(\"https:\") ? https : http).request(url, opts);\n    const promise = new Promise((resolve, reject)=>{\n        req.once(\"response\", resolve).once(\"error\", reject).end();\n    });\n    req.then = promise.then.bind(promise);\n    return req;\n}\nexports.req = req; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9kaXN0L2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElBQUssU0FBVUMsR0FBRztJQUMzRCxJQUFJQSxPQUFPQSxJQUFJVixVQUFVLEVBQUUsT0FBT1U7SUFDbEMsSUFBSUMsU0FBUyxDQUFDO0lBQ2QsSUFBSUQsT0FBTyxNQUFNO1FBQUEsSUFBSyxJQUFJZixLQUFLZSxJQUFLLElBQUlmLE1BQU0sYUFBYUosT0FBT3FCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLEtBQUtmLElBQUlMLGdCQUFnQnFCLFFBQVFELEtBQUtmO0lBQUU7SUFDeElXLG1CQUFtQkssUUFBUUQ7SUFDM0IsT0FBT0M7QUFDWDtBQUNBcEIsOENBQTZDO0lBQUVpQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdETyxXQUFXLEdBQUdBLFlBQVksR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUNyRCxNQUFNSSxPQUFPVixhQUFhVyxtQkFBT0EsQ0FBQyxrQkFBTTtBQUN4QyxNQUFNQyxRQUFRWixhQUFhVyxtQkFBT0EsQ0FBQyxvQkFBTztBQUMxQyxlQUFlRixTQUFTSSxNQUFNO0lBQzFCLElBQUlDLFNBQVM7SUFDYixNQUFNQyxTQUFTLEVBQUU7SUFDakIsV0FBVyxNQUFNQyxTQUFTSCxPQUFRO1FBQzlCQyxVQUFVRSxNQUFNRixNQUFNO1FBQ3RCQyxPQUFPRSxJQUFJLENBQUNEO0lBQ2hCO0lBQ0EsT0FBT0UsT0FBT0MsTUFBTSxDQUFDSixRQUFRRDtBQUNqQztBQUNBUixnQkFBZ0IsR0FBR0c7QUFDbkIsOERBQThEO0FBQzlELGVBQWVELEtBQUtLLE1BQU07SUFDdEIsTUFBTU8sTUFBTSxNQUFNWCxTQUFTSTtJQUMzQixNQUFNUSxNQUFNRCxJQUFJRSxRQUFRLENBQUM7SUFDekIsSUFBSTtRQUNBLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0g7SUFDdEIsRUFDQSxPQUFPSSxNQUFNO1FBQ1QsTUFBTUMsTUFBTUQ7UUFDWkMsSUFBSUMsT0FBTyxJQUFJLENBQUMsU0FBUyxFQUFFTixJQUFJLENBQUMsQ0FBQztRQUNqQyxNQUFNSztJQUNWO0FBQ0o7QUFDQXBCLFlBQVksR0FBR0U7QUFDZixTQUFTRCxJQUFJcUIsR0FBRyxFQUFFQyxPQUFPLENBQUMsQ0FBQztJQUN2QixNQUFNQyxPQUFPLE9BQU9GLFFBQVEsV0FBV0EsTUFBTUEsSUFBSUUsSUFBSTtJQUNyRCxNQUFNdkIsTUFBTSxDQUFDdUIsS0FBS0MsVUFBVSxDQUFDLFlBQVluQixRQUFRRixJQUFHLEVBQUdzQixPQUFPLENBQUNKLEtBQUtDO0lBQ3BFLE1BQU1JLFVBQVUsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUNsQzdCLElBQ0s4QixJQUFJLENBQUMsWUFBWUYsU0FDakJFLElBQUksQ0FBQyxTQUFTRCxRQUNkRSxHQUFHO0lBQ1o7SUFDQS9CLElBQUlnQyxJQUFJLEdBQUdOLFFBQVFNLElBQUksQ0FBQ0MsSUFBSSxDQUFDUDtJQUM3QixPQUFPMUI7QUFDWDtBQUNBRCxXQUFXLEdBQUdDLEtBQ2QsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXp1cmUtb3Blbi1haS1hY2NlbGVyYXRvci8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9kaXN0L2hlbHBlcnMuanM/Y2Y0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXEgPSBleHBvcnRzLmpzb24gPSBleHBvcnRzLnRvQnVmZmVyID0gdm9pZCAwO1xuY29uc3QgaHR0cCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaHR0cFwiKSk7XG5jb25zdCBodHRwcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaHR0cHNcIikpO1xuYXN5bmMgZnVuY3Rpb24gdG9CdWZmZXIoc3RyZWFtKSB7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgbGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChjaHVua3MsIGxlbmd0aCk7XG59XG5leHBvcnRzLnRvQnVmZmVyID0gdG9CdWZmZXI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuYXN5bmMgZnVuY3Rpb24ganNvbihzdHJlYW0pIHtcbiAgICBjb25zdCBidWYgPSBhd2FpdCB0b0J1ZmZlcihzdHJlYW0pO1xuICAgIGNvbnN0IHN0ciA9IGJ1Zi50b1N0cmluZygndXRmOCcpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IF9lcnI7XG4gICAgICAgIGVyci5tZXNzYWdlICs9IGAgKGlucHV0OiAke3N0cn0pYDtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cbmV4cG9ydHMuanNvbiA9IGpzb247XG5mdW5jdGlvbiByZXEodXJsLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBocmVmID0gdHlwZW9mIHVybCA9PT0gJ3N0cmluZycgPyB1cmwgOiB1cmwuaHJlZjtcbiAgICBjb25zdCByZXEgPSAoaHJlZi5zdGFydHNXaXRoKCdodHRwczonKSA/IGh0dHBzIDogaHR0cCkucmVxdWVzdCh1cmwsIG9wdHMpO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlcVxuICAgICAgICAgICAgLm9uY2UoJ3Jlc3BvbnNlJywgcmVzb2x2ZSlcbiAgICAgICAgICAgIC5vbmNlKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgICAgIC5lbmQoKTtcbiAgICB9KTtcbiAgICByZXEudGhlbiA9IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpO1xuICAgIHJldHVybiByZXE7XG59XG5leHBvcnRzLnJlcSA9IHJlcTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImV4cG9ydHMiLCJyZXEiLCJqc29uIiwidG9CdWZmZXIiLCJodHRwIiwicmVxdWlyZSIsImh0dHBzIiwic3RyZWFtIiwibGVuZ3RoIiwiY2h1bmtzIiwiY2h1bmsiLCJwdXNoIiwiQnVmZmVyIiwiY29uY2F0IiwiYnVmIiwic3RyIiwidG9TdHJpbmciLCJKU09OIiwicGFyc2UiLCJfZXJyIiwiZXJyIiwibWVzc2FnZSIsInVybCIsIm9wdHMiLCJocmVmIiwic3RhcnRzV2l0aCIsInJlcXVlc3QiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbmNlIiwiZW5kIiwidGhlbiIsImJpbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/helpers.js":
/*!********************************************************************************!*\
  !*** ./node_modules/https-proxy-agent/node_modules/agent-base/dist/helpers.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.req = exports.json = exports.toBuffer = void 0;\nconst http = __importStar(__webpack_require__(/*! http */ \"http\"));\nconst https = __importStar(__webpack_require__(/*! https */ \"https\"));\nasync function toBuffer(stream) {\n    let length = 0;\n    const chunks = [];\n    for await (const chunk of stream){\n        length += chunk.length;\n        chunks.push(chunk);\n    }\n    return Buffer.concat(chunks, length);\n}\nexports.toBuffer = toBuffer;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function json(stream) {\n    const buf = await toBuffer(stream);\n    const str = buf.toString(\"utf8\");\n    try {\n        return JSON.parse(str);\n    } catch (_err) {\n        const err = _err;\n        err.message += ` (input: ${str})`;\n        throw err;\n    }\n}\nexports.json = json;\nfunction req(url, opts = {}) {\n    const href = typeof url === \"string\" ? url : url.href;\n    const req = (href.startsWith(\"https:\") ? https : http).request(url, opts);\n    const promise = new Promise((resolve, reject)=>{\n        req.once(\"response\", resolve).once(\"error\", reject).end();\n    });\n    req.then = promise.then.bind(promise);\n    return req;\n}\nexports.req = req; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvbm9kZV9tb2R1bGVzL2FnZW50LWJhc2UvZGlzdC9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVVDLEdBQUc7SUFDM0QsSUFBSUEsT0FBT0EsSUFBSVYsVUFBVSxFQUFFLE9BQU9VO0lBQ2xDLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUlELE9BQU8sTUFBTTtRQUFBLElBQUssSUFBSWYsS0FBS2UsSUFBSyxJQUFJZixNQUFNLGFBQWFKLE9BQU9xQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixLQUFLZixJQUFJTCxnQkFBZ0JxQixRQUFRRCxLQUFLZjtJQUFFO0lBQ3hJVyxtQkFBbUJLLFFBQVFEO0lBQzNCLE9BQU9DO0FBQ1g7QUFDQXBCLDhDQUE2QztJQUFFaUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RE8sV0FBVyxHQUFHQSxZQUFZLEdBQUdBLGdCQUFnQixHQUFHLEtBQUs7QUFDckQsTUFBTUksT0FBT1YsYUFBYVcsbUJBQU9BLENBQUMsa0JBQU07QUFDeEMsTUFBTUMsUUFBUVosYUFBYVcsbUJBQU9BLENBQUMsb0JBQU87QUFDMUMsZUFBZUYsU0FBU0ksTUFBTTtJQUMxQixJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsU0FBUyxFQUFFO0lBQ2pCLFdBQVcsTUFBTUMsU0FBU0gsT0FBUTtRQUM5QkMsVUFBVUUsTUFBTUYsTUFBTTtRQUN0QkMsT0FBT0UsSUFBSSxDQUFDRDtJQUNoQjtJQUNBLE9BQU9FLE9BQU9DLE1BQU0sQ0FBQ0osUUFBUUQ7QUFDakM7QUFDQVIsZ0JBQWdCLEdBQUdHO0FBQ25CLDhEQUE4RDtBQUM5RCxlQUFlRCxLQUFLSyxNQUFNO0lBQ3RCLE1BQU1PLE1BQU0sTUFBTVgsU0FBU0k7SUFDM0IsTUFBTVEsTUFBTUQsSUFBSUUsUUFBUSxDQUFDO0lBQ3pCLElBQUk7UUFDQSxPQUFPQyxLQUFLQyxLQUFLLENBQUNIO0lBQ3RCLEVBQ0EsT0FBT0ksTUFBTTtRQUNULE1BQU1DLE1BQU1EO1FBQ1pDLElBQUlDLE9BQU8sSUFBSSxDQUFDLFNBQVMsRUFBRU4sSUFBSSxDQUFDLENBQUM7UUFDakMsTUFBTUs7SUFDVjtBQUNKO0FBQ0FwQixZQUFZLEdBQUdFO0FBQ2YsU0FBU0QsSUFBSXFCLEdBQUcsRUFBRUMsT0FBTyxDQUFDLENBQUM7SUFDdkIsTUFBTUMsT0FBTyxPQUFPRixRQUFRLFdBQVdBLE1BQU1BLElBQUlFLElBQUk7SUFDckQsTUFBTXZCLE1BQU0sQ0FBQ3VCLEtBQUtDLFVBQVUsQ0FBQyxZQUFZbkIsUUFBUUYsSUFBRyxFQUFHc0IsT0FBTyxDQUFDSixLQUFLQztJQUNwRSxNQUFNSSxVQUFVLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDbEM3QixJQUNLOEIsSUFBSSxDQUFDLFlBQVlGLFNBQ2pCRSxJQUFJLENBQUMsU0FBU0QsUUFDZEUsR0FBRztJQUNaO0lBQ0EvQixJQUFJZ0MsSUFBSSxHQUFHTixRQUFRTSxJQUFJLENBQUNDLElBQUksQ0FBQ1A7SUFDN0IsT0FBTzFCO0FBQ1g7QUFDQUQsV0FBVyxHQUFHQyxLQUNkLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2F6dXJlLW9wZW4tYWktYWNjZWxlcmF0b3IvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvbm9kZV9tb2R1bGVzL2FnZW50LWJhc2UvZGlzdC9oZWxwZXJzLmpzP2NmNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVxID0gZXhwb3J0cy5qc29uID0gZXhwb3J0cy50b0J1ZmZlciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBcIikpO1xuY29uc3QgaHR0cHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBzXCIpKTtcbmFzeW5jIGZ1bmN0aW9uIHRvQnVmZmVyKHN0cmVhbSkge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgIGxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBsZW5ndGgpO1xufVxuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmFzeW5jIGZ1bmN0aW9uIGpzb24oc3RyZWFtKSB7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgdG9CdWZmZXIoc3RyZWFtKTtcbiAgICBjb25zdCBzdHIgPSBidWYudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICBjb25zdCBlcnIgPSBfZXJyO1xuICAgICAgICBlcnIubWVzc2FnZSArPSBgIChpbnB1dDogJHtzdHJ9KWA7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5leHBvcnRzLmpzb24gPSBqc29uO1xuZnVuY3Rpb24gcmVxKHVybCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgaHJlZiA9IHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnID8gdXJsIDogdXJsLmhyZWY7XG4gICAgY29uc3QgcmVxID0gKGhyZWYuc3RhcnRzV2l0aCgnaHR0cHM6JykgPyBodHRwcyA6IGh0dHApLnJlcXVlc3QodXJsLCBvcHRzKTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXFcbiAgICAgICAgICAgIC5vbmNlKCdyZXNwb25zZScsIHJlc29sdmUpXG4gICAgICAgICAgICAub25jZSgnZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAuZW5kKCk7XG4gICAgfSk7XG4gICAgcmVxLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKTtcbiAgICByZXR1cm4gcmVxO1xufVxuZXhwb3J0cy5yZXEgPSByZXE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJleHBvcnRzIiwicmVxIiwianNvbiIsInRvQnVmZmVyIiwiaHR0cCIsInJlcXVpcmUiLCJodHRwcyIsInN0cmVhbSIsImxlbmd0aCIsImNodW5rcyIsImNodW5rIiwicHVzaCIsIkJ1ZmZlciIsImNvbmNhdCIsImJ1ZiIsInN0ciIsInRvU3RyaW5nIiwiSlNPTiIsInBhcnNlIiwiX2VyciIsImVyciIsIm1lc3NhZ2UiLCJ1cmwiLCJvcHRzIiwiaHJlZiIsInN0YXJ0c1dpdGgiLCJyZXF1ZXN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25jZSIsImVuZCIsInRoZW4iLCJiaW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/helpers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/https-proxy-agent/node_modules/agent-base/dist/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Agent = void 0;\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst http = __importStar(__webpack_require__(/*! http */ \"http\"));\nconst https_1 = __webpack_require__(/*! https */ \"https\");\n__exportStar(__webpack_require__(/*! ./helpers */ \"(action-browser)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/helpers.js\"), exports);\nconst INTERNAL = Symbol(\"AgentBaseInternalState\");\nclass Agent extends http.Agent {\n    constructor(opts){\n        super(opts);\n        this[INTERNAL] = {};\n    }\n    /**\n     * Determine whether this is an `http` or `https` request.\n     */ isSecureEndpoint(options) {\n        if (options) {\n            // First check the `secureEndpoint` property explicitly, since this\n            // means that a parent `Agent` is \"passing through\" to this instance.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (typeof options.secureEndpoint === \"boolean\") {\n                return options.secureEndpoint;\n            }\n            // If no explicit `secure` endpoint, check if `protocol` property is\n            // set. This will usually be the case since using a full string URL\n            // or `URL` instance should be the most common usage.\n            if (typeof options.protocol === \"string\") {\n                return options.protocol === \"https:\";\n            }\n        }\n        // Finally, if no `protocol` property was set, then fall back to\n        // checking the stack trace of the current call stack, and try to\n        // detect the \"https\" module.\n        const { stack } = new Error();\n        if (typeof stack !== \"string\") return false;\n        return stack.split(\"\\n\").some((l)=>l.indexOf(\"(https.js:\") !== -1 || l.indexOf(\"node:https:\") !== -1);\n    }\n    // In order to support async signatures in `connect()` and Node's native\n    // connection pooling in `http.Agent`, the array of sockets for each origin\n    // has to be updated synchronously. This is so the length of the array is\n    // accurate when `addRequest()` is next called. We achieve this by creating a\n    // fake socket and adding it to `sockets[origin]` and incrementing\n    // `totalSocketCount`.\n    incrementSockets(name) {\n        // If `maxSockets` and `maxTotalSockets` are both Infinity then there is no\n        // need to create a fake socket because Node.js native connection pooling\n        // will never be invoked.\n        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {\n            return null;\n        }\n        // All instances of `sockets` are expected TypeScript errors. The\n        // alternative is to add it as a private property of this class but that\n        // will break TypeScript subclassing.\n        if (!this.sockets[name]) {\n            // @ts-expect-error `sockets` is readonly in `@types/node`\n            this.sockets[name] = [];\n        }\n        const fakeSocket = new net.Socket({\n            writable: false\n        });\n        this.sockets[name].push(fakeSocket);\n        // @ts-expect-error `totalSocketCount` isn't defined in `@types/node`\n        this.totalSocketCount++;\n        return fakeSocket;\n    }\n    decrementSockets(name, socket) {\n        if (!this.sockets[name] || socket === null) {\n            return;\n        }\n        const sockets = this.sockets[name];\n        const index = sockets.indexOf(socket);\n        if (index !== -1) {\n            sockets.splice(index, 1);\n            // @ts-expect-error  `totalSocketCount` isn't defined in `@types/node`\n            this.totalSocketCount--;\n            if (sockets.length === 0) {\n                // @ts-expect-error `sockets` is readonly in `@types/node`\n                delete this.sockets[name];\n            }\n        }\n    }\n    // In order to properly update the socket pool, we need to call `getName()` on\n    // the core `https.Agent` if it is a secureEndpoint.\n    getName(options) {\n        const secureEndpoint = typeof options.secureEndpoint === \"boolean\" ? options.secureEndpoint : this.isSecureEndpoint(options);\n        if (secureEndpoint) {\n            // @ts-expect-error `getName()` isn't defined in `@types/node`\n            return https_1.Agent.prototype.getName.call(this, options);\n        }\n        // @ts-expect-error `getName()` isn't defined in `@types/node`\n        return super.getName(options);\n    }\n    createSocket(req, options, cb) {\n        const connectOpts = {\n            ...options,\n            secureEndpoint: this.isSecureEndpoint(options)\n        };\n        const name = this.getName(connectOpts);\n        const fakeSocket = this.incrementSockets(name);\n        Promise.resolve().then(()=>this.connect(req, connectOpts)).then((socket)=>{\n            this.decrementSockets(name, fakeSocket);\n            if (socket instanceof http.Agent) {\n                try {\n                    // @ts-expect-error `addRequest()` isn't defined in `@types/node`\n                    return socket.addRequest(req, connectOpts);\n                } catch (err) {\n                    return cb(err);\n                }\n            }\n            this[INTERNAL].currentSocket = socket;\n            // @ts-expect-error `createSocket()` isn't defined in `@types/node`\n            super.createSocket(req, options, cb);\n        }, (err)=>{\n            this.decrementSockets(name, fakeSocket);\n            cb(err);\n        });\n    }\n    createConnection() {\n        const socket = this[INTERNAL].currentSocket;\n        this[INTERNAL].currentSocket = undefined;\n        if (!socket) {\n            throw new Error(\"No socket was returned in the `connect()` function\");\n        }\n        return socket;\n    }\n    get defaultPort() {\n        return this[INTERNAL].defaultPort ?? (this.protocol === \"https:\" ? 443 : 80);\n    }\n    set defaultPort(v) {\n        if (this[INTERNAL]) {\n            this[INTERNAL].defaultPort = v;\n        }\n    }\n    get protocol() {\n        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? \"https:\" : \"http:\");\n    }\n    set protocol(v) {\n        if (this[INTERNAL]) {\n            this[INTERNAL].protocol = v;\n        }\n    }\n}\nexports.Agent = Agent; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJ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SUFDSjtJQUNBLElBQUl1QixXQUFXO1FBQ1gsT0FBUSxJQUFJLENBQUNQLFNBQVMsQ0FBQ08sUUFBUSxJQUMxQixLQUFJLENBQUNILGdCQUFnQixLQUFLLFdBQVcsT0FBTTtJQUNwRDtJQUNBLElBQUlHLFNBQVN2QixDQUFDLEVBQUU7UUFDWixJQUFJLElBQUksQ0FBQ2dCLFNBQVMsRUFBRTtZQUNoQixJQUFJLENBQUNBLFNBQVMsQ0FBQ08sUUFBUSxHQUFHdkI7UUFDOUI7SUFDSjtBQUNKO0FBQ0FTLGFBQWEsR0FBR0UsT0FDaEIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXp1cmUtb3Blbi1haS1hY2NlbGVyYXRvci8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9kaXN0L2luZGV4LmpzPzFmOGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFnZW50ID0gdm9pZCAwO1xuY29uc3QgbmV0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJuZXRcIikpO1xuY29uc3QgaHR0cCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaHR0cFwiKSk7XG5jb25zdCBodHRwc18xID0gcmVxdWlyZShcImh0dHBzXCIpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlcnNcIiksIGV4cG9ydHMpO1xuY29uc3QgSU5URVJOQUwgPSBTeW1ib2woJ0FnZW50QmFzZUludGVybmFsU3RhdGUnKTtcbmNsYXNzIEFnZW50IGV4dGVuZHMgaHR0cC5BZ2VudCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpc1tJTlRFUk5BTF0gPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhbiBgaHR0cGAgb3IgYGh0dHBzYCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGlzU2VjdXJlRW5kcG9pbnQob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgdGhlIGBzZWN1cmVFbmRwb2ludGAgcHJvcGVydHkgZXhwbGljaXRseSwgc2luY2UgdGhpc1xuICAgICAgICAgICAgLy8gbWVhbnMgdGhhdCBhIHBhcmVudCBgQWdlbnRgIGlzIFwicGFzc2luZyB0aHJvdWdoXCIgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2VjdXJlRW5kcG9pbnQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnNlY3VyZUVuZHBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgYHNlY3VyZWAgZW5kcG9pbnQsIGNoZWNrIGlmIGBwcm90b2NvbGAgcHJvcGVydHkgaXNcbiAgICAgICAgICAgIC8vIHNldC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgdGhlIGNhc2Ugc2luY2UgdXNpbmcgYSBmdWxsIHN0cmluZyBVUkxcbiAgICAgICAgICAgIC8vIG9yIGBVUkxgIGluc3RhbmNlIHNob3VsZCBiZSB0aGUgbW9zdCBjb21tb24gdXNhZ2UuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJvdG9jb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmFsbHksIGlmIG5vIGBwcm90b2NvbGAgcHJvcGVydHkgd2FzIHNldCwgdGhlbiBmYWxsIGJhY2sgdG9cbiAgICAgICAgLy8gY2hlY2tpbmcgdGhlIHN0YWNrIHRyYWNlIG9mIHRoZSBjdXJyZW50IGNhbGwgc3RhY2ssIGFuZCB0cnkgdG9cbiAgICAgICAgLy8gZGV0ZWN0IHRoZSBcImh0dHBzXCIgbW9kdWxlLlxuICAgICAgICBjb25zdCB7IHN0YWNrIH0gPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdGFja1xuICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgLnNvbWUoKGwpID0+IGwuaW5kZXhPZignKGh0dHBzLmpzOicpICE9PSAtMSB8fFxuICAgICAgICAgICAgbC5pbmRleE9mKCdub2RlOmh0dHBzOicpICE9PSAtMSk7XG4gICAgfVxuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgYXN5bmMgc2lnbmF0dXJlcyBpbiBgY29ubmVjdCgpYCBhbmQgTm9kZSdzIG5hdGl2ZVxuICAgIC8vIGNvbm5lY3Rpb24gcG9vbGluZyBpbiBgaHR0cC5BZ2VudGAsIHRoZSBhcnJheSBvZiBzb2NrZXRzIGZvciBlYWNoIG9yaWdpblxuICAgIC8vIGhhcyB0byBiZSB1cGRhdGVkIHN5bmNocm9ub3VzbHkuIFRoaXMgaXMgc28gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaXNcbiAgICAvLyBhY2N1cmF0ZSB3aGVuIGBhZGRSZXF1ZXN0KClgIGlzIG5leHQgY2FsbGVkLiBXZSBhY2hpZXZlIHRoaXMgYnkgY3JlYXRpbmcgYVxuICAgIC8vIGZha2Ugc29ja2V0IGFuZCBhZGRpbmcgaXQgdG8gYHNvY2tldHNbb3JpZ2luXWAgYW5kIGluY3JlbWVudGluZ1xuICAgIC8vIGB0b3RhbFNvY2tldENvdW50YC5cbiAgICBpbmNyZW1lbnRTb2NrZXRzKG5hbWUpIHtcbiAgICAgICAgLy8gSWYgYG1heFNvY2tldHNgIGFuZCBgbWF4VG90YWxTb2NrZXRzYCBhcmUgYm90aCBJbmZpbml0eSB0aGVuIHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIG5lZWQgdG8gY3JlYXRlIGEgZmFrZSBzb2NrZXQgYmVjYXVzZSBOb2RlLmpzIG5hdGl2ZSBjb25uZWN0aW9uIHBvb2xpbmdcbiAgICAgICAgLy8gd2lsbCBuZXZlciBiZSBpbnZva2VkLlxuICAgICAgICBpZiAodGhpcy5tYXhTb2NrZXRzID09PSBJbmZpbml0eSAmJiB0aGlzLm1heFRvdGFsU29ja2V0cyA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbCBpbnN0YW5jZXMgb2YgYHNvY2tldHNgIGFyZSBleHBlY3RlZCBUeXBlU2NyaXB0IGVycm9ycy4gVGhlXG4gICAgICAgIC8vIGFsdGVybmF0aXZlIGlzIHRvIGFkZCBpdCBhcyBhIHByaXZhdGUgcHJvcGVydHkgb2YgdGhpcyBjbGFzcyBidXQgdGhhdFxuICAgICAgICAvLyB3aWxsIGJyZWFrIFR5cGVTY3JpcHQgc3ViY2xhc3NpbmcuXG4gICAgICAgIGlmICghdGhpcy5zb2NrZXRzW25hbWVdKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBzb2NrZXRzYCBpcyByZWFkb25seSBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICB0aGlzLnNvY2tldHNbbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWtlU29ja2V0ID0gbmV3IG5ldC5Tb2NrZXQoeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0c1tuYW1lXS5wdXNoKGZha2VTb2NrZXQpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGB0b3RhbFNvY2tldENvdW50YCBpc24ndCBkZWZpbmVkIGluIGBAdHlwZXMvbm9kZWBcbiAgICAgICAgdGhpcy50b3RhbFNvY2tldENvdW50Kys7XG4gICAgICAgIHJldHVybiBmYWtlU29ja2V0O1xuICAgIH1cbiAgICBkZWNyZW1lbnRTb2NrZXRzKG5hbWUsIHNvY2tldCkge1xuICAgICAgICBpZiAoIXRoaXMuc29ja2V0c1tuYW1lXSB8fCBzb2NrZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRzID0gdGhpcy5zb2NrZXRzW25hbWVdO1xuICAgICAgICBjb25zdCBpbmRleCA9IHNvY2tldHMuaW5kZXhPZihzb2NrZXQpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBzb2NrZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICBgdG90YWxTb2NrZXRDb3VudGAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICB0aGlzLnRvdGFsU29ja2V0Q291bnQtLTtcbiAgICAgICAgICAgIGlmIChzb2NrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYHNvY2tldHNgIGlzIHJlYWRvbmx5IGluIGBAdHlwZXMvbm9kZWBcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zb2NrZXRzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEluIG9yZGVyIHRvIHByb3Blcmx5IHVwZGF0ZSB0aGUgc29ja2V0IHBvb2wsIHdlIG5lZWQgdG8gY2FsbCBgZ2V0TmFtZSgpYCBvblxuICAgIC8vIHRoZSBjb3JlIGBodHRwcy5BZ2VudGAgaWYgaXQgaXMgYSBzZWN1cmVFbmRwb2ludC5cbiAgICBnZXROYW1lKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VjdXJlRW5kcG9pbnQgPSB0eXBlb2Ygb3B0aW9ucy5zZWN1cmVFbmRwb2ludCA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICA/IG9wdGlvbnMuc2VjdXJlRW5kcG9pbnRcbiAgICAgICAgICAgIDogdGhpcy5pc1NlY3VyZUVuZHBvaW50KG9wdGlvbnMpO1xuICAgICAgICBpZiAoc2VjdXJlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGdldE5hbWUoKWAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICByZXR1cm4gaHR0cHNfMS5BZ2VudC5wcm90b3R5cGUuZ2V0TmFtZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGdldE5hbWUoKWAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgIHJldHVybiBzdXBlci5nZXROYW1lKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjcmVhdGVTb2NrZXQocmVxLCBvcHRpb25zLCBjYikge1xuICAgICAgICBjb25zdCBjb25uZWN0T3B0cyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBzZWN1cmVFbmRwb2ludDogdGhpcy5pc1NlY3VyZUVuZHBvaW50KG9wdGlvbnMpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXROYW1lKGNvbm5lY3RPcHRzKTtcbiAgICAgICAgY29uc3QgZmFrZVNvY2tldCA9IHRoaXMuaW5jcmVtZW50U29ja2V0cyhuYW1lKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuY29ubmVjdChyZXEsIGNvbm5lY3RPcHRzKSlcbiAgICAgICAgICAgIC50aGVuKChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50U29ja2V0cyhuYW1lLCBmYWtlU29ja2V0KTtcbiAgICAgICAgICAgIGlmIChzb2NrZXQgaW5zdGFuY2VvZiBodHRwLkFnZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgYWRkUmVxdWVzdCgpYCBpc24ndCBkZWZpbmVkIGluIGBAdHlwZXMvbm9kZWBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5hZGRSZXF1ZXN0KHJlcSwgY29ubmVjdE9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbSU5URVJOQUxdLmN1cnJlbnRTb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBjcmVhdGVTb2NrZXQoKWAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICBzdXBlci5jcmVhdGVTb2NrZXQocmVxLCBvcHRpb25zLCBjYik7XG4gICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50U29ja2V0cyhuYW1lLCBmYWtlU29ja2V0KTtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVDb25uZWN0aW9uKCkge1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzW0lOVEVSTkFMXS5jdXJyZW50U29ja2V0O1xuICAgICAgICB0aGlzW0lOVEVSTkFMXS5jdXJyZW50U29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzb2NrZXQgd2FzIHJldHVybmVkIGluIHRoZSBgY29ubmVjdCgpYCBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgfVxuICAgIGdldCBkZWZhdWx0UG9ydCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzW0lOVEVSTkFMXS5kZWZhdWx0UG9ydCA/P1xuICAgICAgICAgICAgKHRoaXMucHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODApKTtcbiAgICB9XG4gICAgc2V0IGRlZmF1bHRQb3J0KHYpIHtcbiAgICAgICAgaWYgKHRoaXNbSU5URVJOQUxdKSB7XG4gICAgICAgICAgICB0aGlzW0lOVEVSTkFMXS5kZWZhdWx0UG9ydCA9IHY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHByb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gKHRoaXNbSU5URVJOQUxdLnByb3RvY29sID8/XG4gICAgICAgICAgICAodGhpcy5pc1NlY3VyZUVuZHBvaW50KCkgPyAnaHR0cHM6JyA6ICdodHRwOicpKTtcbiAgICB9XG4gICAgc2V0IHByb3RvY29sKHYpIHtcbiAgICAgICAgaWYgKHRoaXNbSU5URVJOQUxdKSB7XG4gICAgICAgICAgICB0aGlzW0lOVEVSTkFMXS5wcm90b2NvbCA9IHY7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFnZW50ID0gQWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJBZ2VudCIsIm5ldCIsInJlcXVpcmUiLCJodHRwIiwiaHR0cHNfMSIsIklOVEVSTkFMIiwiU3ltYm9sIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiaXNTZWN1cmVFbmRwb2ludCIsIm9wdGlvbnMiLCJzZWN1cmVFbmRwb2ludCIsInByb3RvY29sIiwic3RhY2siLCJFcnJvciIsInNwbGl0Iiwic29tZSIsImwiLCJpbmRleE9mIiwiaW5jcmVtZW50U29ja2V0cyIsIm5hbWUiLCJtYXhTb2NrZXRzIiwiSW5maW5pdHkiLCJtYXhUb3RhbFNvY2tldHMiLCJzb2NrZXRzIiwiZmFrZVNvY2tldCIsIlNvY2tldCIsInB1c2giLCJ0b3RhbFNvY2tldENvdW50IiwiZGVjcmVtZW50U29ja2V0cyIsInNvY2tldCIsImluZGV4Iiwic3BsaWNlIiwibGVuZ3RoIiwiZ2V0TmFtZSIsImNyZWF0ZVNvY2tldCIsInJlcSIsImNiIiwiY29ubmVjdE9wdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjb25uZWN0IiwiYWRkUmVxdWVzdCIsImVyciIsImN1cnJlbnRTb2NrZXQiLCJjcmVhdGVDb25uZWN0aW9uIiwiZGVmYXVsdFBvcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/https-proxy-agent/node_modules/agent-base/dist/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Agent = void 0;\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst http = __importStar(__webpack_require__(/*! http */ \"http\"));\nconst https_1 = __webpack_require__(/*! https */ \"https\");\n__exportStar(__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/helpers.js\"), exports);\nconst INTERNAL = Symbol(\"AgentBaseInternalState\");\nclass Agent extends http.Agent {\n    constructor(opts){\n        super(opts);\n        this[INTERNAL] = {};\n    }\n    /**\n     * Determine whether this is an `http` or `https` request.\n     */ isSecureEndpoint(options) {\n        if (options) {\n            // First check the `secureEndpoint` property explicitly, since this\n            // means that a parent `Agent` is \"passing through\" to this instance.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (typeof options.secureEndpoint === \"boolean\") {\n                return options.secureEndpoint;\n            }\n            // If no explicit `secure` endpoint, check if `protocol` property is\n            // set. This will usually be the case since using a full string URL\n            // or `URL` instance should be the most common usage.\n            if (typeof options.protocol === \"string\") {\n                return options.protocol === \"https:\";\n            }\n        }\n        // Finally, if no `protocol` property was set, then fall back to\n        // checking the stack trace of the current call stack, and try to\n        // detect the \"https\" module.\n        const { stack } = new Error();\n        if (typeof stack !== \"string\") return false;\n        return stack.split(\"\\n\").some((l)=>l.indexOf(\"(https.js:\") !== -1 || l.indexOf(\"node:https:\") !== -1);\n    }\n    // In order to support async signatures in `connect()` and Node's native\n    // connection pooling in `http.Agent`, the array of sockets for each origin\n    // has to be updated synchronously. This is so the length of the array is\n    // accurate when `addRequest()` is next called. We achieve this by creating a\n    // fake socket and adding it to `sockets[origin]` and incrementing\n    // `totalSocketCount`.\n    incrementSockets(name) {\n        // If `maxSockets` and `maxTotalSockets` are both Infinity then there is no\n        // need to create a fake socket because Node.js native connection pooling\n        // will never be invoked.\n        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {\n            return null;\n        }\n        // All instances of `sockets` are expected TypeScript errors. The\n        // alternative is to add it as a private property of this class but that\n        // will break TypeScript subclassing.\n        if (!this.sockets[name]) {\n            // @ts-expect-error `sockets` is readonly in `@types/node`\n            this.sockets[name] = [];\n        }\n        const fakeSocket = new net.Socket({\n            writable: false\n        });\n        this.sockets[name].push(fakeSocket);\n        // @ts-expect-error `totalSocketCount` isn't defined in `@types/node`\n        this.totalSocketCount++;\n        return fakeSocket;\n    }\n    decrementSockets(name, socket) {\n        if (!this.sockets[name] || socket === null) {\n            return;\n        }\n        const sockets = this.sockets[name];\n        const index = sockets.indexOf(socket);\n        if (index !== -1) {\n            sockets.splice(index, 1);\n            // @ts-expect-error  `totalSocketCount` isn't defined in `@types/node`\n            this.totalSocketCount--;\n            if (sockets.length === 0) {\n                // @ts-expect-error `sockets` is readonly in `@types/node`\n                delete this.sockets[name];\n            }\n        }\n    }\n    // In order to properly update the socket pool, we need to call `getName()` on\n    // the core `https.Agent` if it is a secureEndpoint.\n    getName(options) {\n        const secureEndpoint = typeof options.secureEndpoint === \"boolean\" ? options.secureEndpoint : this.isSecureEndpoint(options);\n        if (secureEndpoint) {\n            // @ts-expect-error `getName()` isn't defined in `@types/node`\n            return https_1.Agent.prototype.getName.call(this, options);\n        }\n        // @ts-expect-error `getName()` isn't defined in `@types/node`\n        return super.getName(options);\n    }\n    createSocket(req, options, cb) {\n        const connectOpts = {\n            ...options,\n            secureEndpoint: this.isSecureEndpoint(options)\n        };\n        const name = this.getName(connectOpts);\n        const fakeSocket = this.incrementSockets(name);\n        Promise.resolve().then(()=>this.connect(req, connectOpts)).then((socket)=>{\n            this.decrementSockets(name, fakeSocket);\n            if (socket instanceof http.Agent) {\n                try {\n                    // @ts-expect-error `addRequest()` isn't defined in `@types/node`\n                    return socket.addRequest(req, connectOpts);\n                } catch (err) {\n                    return cb(err);\n                }\n            }\n            this[INTERNAL].currentSocket = socket;\n            // @ts-expect-error `createSocket()` isn't defined in `@types/node`\n            super.createSocket(req, options, cb);\n        }, (err)=>{\n            this.decrementSockets(name, fakeSocket);\n            cb(err);\n        });\n    }\n    createConnection() {\n        const socket = this[INTERNAL].currentSocket;\n        this[INTERNAL].currentSocket = undefined;\n        if (!socket) {\n            throw new Error(\"No socket was returned in the `connect()` function\");\n        }\n        return socket;\n    }\n    get defaultPort() {\n        return this[INTERNAL].defaultPort ?? (this.protocol === \"https:\" ? 443 : 80);\n    }\n    set defaultPort(v) {\n        if (this[INTERNAL]) {\n            this[INTERNAL].defaultPort = v;\n        }\n    }\n    get protocol() {\n        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? \"https:\" : \"http:\");\n    }\n    set protocol(v) {\n        if (this[INTERNAL]) {\n            this[INTERNAL].protocol = v;\n        }\n    }\n}\nexports.Agent = Agent; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvbm9kZV9tb2R1bGVzL2FnZW50LWJhc2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxD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QUFJdUIsV0FBVztRQUNYLE9BQVEsSUFBSSxDQUFDUCxTQUFTLENBQUNPLFFBQVEsSUFDMUIsS0FBSSxDQUFDSCxnQkFBZ0IsS0FBSyxXQUFXLE9BQU07SUFDcEQ7SUFDQSxJQUFJRyxTQUFTdkIsQ0FBQyxFQUFFO1FBQ1osSUFBSSxJQUFJLENBQUNnQixTQUFTLEVBQUU7WUFDaEIsSUFBSSxDQUFDQSxTQUFTLENBQUNPLFFBQVEsR0FBR3ZCO1FBQzlCO0lBQ0o7QUFDSjtBQUNBUyxhQUFhLEdBQUdFLE9BQ2hCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2F6dXJlLW9wZW4tYWktYWNjZWxlcmF0b3IvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvbm9kZV9tb2R1bGVzL2FnZW50LWJhc2UvZGlzdC9pbmRleC5qcz8xZjhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZ2VudCA9IHZvaWQgMDtcbmNvbnN0IG5ldCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibmV0XCIpKTtcbmNvbnN0IGh0dHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBcIikpO1xuY29uc3QgaHR0cHNfMSA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJzXCIpLCBleHBvcnRzKTtcbmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKCdBZ2VudEJhc2VJbnRlcm5hbFN0YXRlJyk7XG5jbGFzcyBBZ2VudCBleHRlbmRzIGh0dHAuQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXNbSU5URVJOQUxdID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYW4gYGh0dHBgIG9yIGBodHRwc2AgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBpc1NlY3VyZUVuZHBvaW50KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIHRoZSBgc2VjdXJlRW5kcG9pbnRgIHByb3BlcnR5IGV4cGxpY2l0bHksIHNpbmNlIHRoaXNcbiAgICAgICAgICAgIC8vIG1lYW5zIHRoYXQgYSBwYXJlbnQgYEFnZW50YCBpcyBcInBhc3NpbmcgdGhyb3VnaFwiIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNlY3VyZUVuZHBvaW50ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5zZWN1cmVFbmRwb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5vIGV4cGxpY2l0IGBzZWN1cmVgIGVuZHBvaW50LCBjaGVjayBpZiBgcHJvdG9jb2xgIHByb3BlcnR5IGlzXG4gICAgICAgICAgICAvLyBzZXQuIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHRoZSBjYXNlIHNpbmNlIHVzaW5nIGEgZnVsbCBzdHJpbmcgVVJMXG4gICAgICAgICAgICAvLyBvciBgVVJMYCBpbnN0YW5jZSBzaG91bGQgYmUgdGhlIG1vc3QgY29tbW9uIHVzYWdlLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnByb3RvY29sID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5LCBpZiBubyBgcHJvdG9jb2xgIHByb3BlcnR5IHdhcyBzZXQsIHRoZW4gZmFsbCBiYWNrIHRvXG4gICAgICAgIC8vIGNoZWNraW5nIHRoZSBzdGFjayB0cmFjZSBvZiB0aGUgY3VycmVudCBjYWxsIHN0YWNrLCBhbmQgdHJ5IHRvXG4gICAgICAgIC8vIGRldGVjdCB0aGUgXCJodHRwc1wiIG1vZHVsZS5cbiAgICAgICAgY29uc3QgeyBzdGFjayB9ID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2sgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RhY2tcbiAgICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgIC5zb21lKChsKSA9PiBsLmluZGV4T2YoJyhodHRwcy5qczonKSAhPT0gLTEgfHxcbiAgICAgICAgICAgIGwuaW5kZXhPZignbm9kZTpodHRwczonKSAhPT0gLTEpO1xuICAgIH1cbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IGFzeW5jIHNpZ25hdHVyZXMgaW4gYGNvbm5lY3QoKWAgYW5kIE5vZGUncyBuYXRpdmVcbiAgICAvLyBjb25uZWN0aW9uIHBvb2xpbmcgaW4gYGh0dHAuQWdlbnRgLCB0aGUgYXJyYXkgb2Ygc29ja2V0cyBmb3IgZWFjaCBvcmlnaW5cbiAgICAvLyBoYXMgdG8gYmUgdXBkYXRlZCBzeW5jaHJvbm91c2x5LiBUaGlzIGlzIHNvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGlzXG4gICAgLy8gYWNjdXJhdGUgd2hlbiBgYWRkUmVxdWVzdCgpYCBpcyBuZXh0IGNhbGxlZC4gV2UgYWNoaWV2ZSB0aGlzIGJ5IGNyZWF0aW5nIGFcbiAgICAvLyBmYWtlIHNvY2tldCBhbmQgYWRkaW5nIGl0IHRvIGBzb2NrZXRzW29yaWdpbl1gIGFuZCBpbmNyZW1lbnRpbmdcbiAgICAvLyBgdG90YWxTb2NrZXRDb3VudGAuXG4gICAgaW5jcmVtZW50U29ja2V0cyhuYW1lKSB7XG4gICAgICAgIC8vIElmIGBtYXhTb2NrZXRzYCBhbmQgYG1heFRvdGFsU29ja2V0c2AgYXJlIGJvdGggSW5maW5pdHkgdGhlbiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBuZWVkIHRvIGNyZWF0ZSBhIGZha2Ugc29ja2V0IGJlY2F1c2UgTm9kZS5qcyBuYXRpdmUgY29ubmVjdGlvbiBwb29saW5nXG4gICAgICAgIC8vIHdpbGwgbmV2ZXIgYmUgaW52b2tlZC5cbiAgICAgICAgaWYgKHRoaXMubWF4U29ja2V0cyA9PT0gSW5maW5pdHkgJiYgdGhpcy5tYXhUb3RhbFNvY2tldHMgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgaW5zdGFuY2VzIG9mIGBzb2NrZXRzYCBhcmUgZXhwZWN0ZWQgVHlwZVNjcmlwdCBlcnJvcnMuIFRoZVxuICAgICAgICAvLyBhbHRlcm5hdGl2ZSBpcyB0byBhZGQgaXQgYXMgYSBwcml2YXRlIHByb3BlcnR5IG9mIHRoaXMgY2xhc3MgYnV0IHRoYXRcbiAgICAgICAgLy8gd2lsbCBicmVhayBUeXBlU2NyaXB0IHN1YmNsYXNzaW5nLlxuICAgICAgICBpZiAoIXRoaXMuc29ja2V0c1tuYW1lXSkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgc29ja2V0c2AgaXMgcmVhZG9ubHkgaW4gYEB0eXBlcy9ub2RlYFxuICAgICAgICAgICAgdGhpcy5zb2NrZXRzW25hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFrZVNvY2tldCA9IG5ldyBuZXQuU29ja2V0KHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLnNvY2tldHNbbmFtZV0ucHVzaChmYWtlU29ja2V0KTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgdG90YWxTb2NrZXRDb3VudGAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgIHRoaXMudG90YWxTb2NrZXRDb3VudCsrO1xuICAgICAgICByZXR1cm4gZmFrZVNvY2tldDtcbiAgICB9XG4gICAgZGVjcmVtZW50U29ja2V0cyhuYW1lLCBzb2NrZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvY2tldHNbbmFtZV0gfHwgc29ja2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0cyA9IHRoaXMuc29ja2V0c1tuYW1lXTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzb2NrZXRzLmluZGV4T2Yoc29ja2V0KTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgc29ja2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAgYHRvdGFsU29ja2V0Q291bnRgIGlzbid0IGRlZmluZWQgaW4gYEB0eXBlcy9ub2RlYFxuICAgICAgICAgICAgdGhpcy50b3RhbFNvY2tldENvdW50LS07XG4gICAgICAgICAgICBpZiAoc29ja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBzb2NrZXRzYCBpcyByZWFkb25seSBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc29ja2V0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbiBvcmRlciB0byBwcm9wZXJseSB1cGRhdGUgdGhlIHNvY2tldCBwb29sLCB3ZSBuZWVkIHRvIGNhbGwgYGdldE5hbWUoKWAgb25cbiAgICAvLyB0aGUgY29yZSBgaHR0cHMuQWdlbnRgIGlmIGl0IGlzIGEgc2VjdXJlRW5kcG9pbnQuXG4gICAgZ2V0TmFtZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNlY3VyZUVuZHBvaW50ID0gdHlwZW9mIG9wdGlvbnMuc2VjdXJlRW5kcG9pbnQgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgPyBvcHRpb25zLnNlY3VyZUVuZHBvaW50XG4gICAgICAgICAgICA6IHRoaXMuaXNTZWN1cmVFbmRwb2ludChvcHRpb25zKTtcbiAgICAgICAgaWYgKHNlY3VyZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBnZXROYW1lKClgIGlzbid0IGRlZmluZWQgaW4gYEB0eXBlcy9ub2RlYFxuICAgICAgICAgICAgcmV0dXJuIGh0dHBzXzEuQWdlbnQucHJvdG90eXBlLmdldE5hbWUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBnZXROYW1lKClgIGlzbid0IGRlZmluZWQgaW4gYEB0eXBlcy9ub2RlYFxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0TmFtZShvcHRpb25zKTtcbiAgICB9XG4gICAgY3JlYXRlU29ja2V0KHJlcSwgb3B0aW9ucywgY2IpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdE9wdHMgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgc2VjdXJlRW5kcG9pbnQ6IHRoaXMuaXNTZWN1cmVFbmRwb2ludChvcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0TmFtZShjb25uZWN0T3B0cyk7XG4gICAgICAgIGNvbnN0IGZha2VTb2NrZXQgPSB0aGlzLmluY3JlbWVudFNvY2tldHMobmFtZSk7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmNvbm5lY3QocmVxLCBjb25uZWN0T3B0cykpXG4gICAgICAgICAgICAudGhlbigoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlY3JlbWVudFNvY2tldHMobmFtZSwgZmFrZVNvY2tldCk7XG4gICAgICAgICAgICBpZiAoc29ja2V0IGluc3RhbmNlb2YgaHR0cC5BZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGFkZFJlcXVlc3QoKWAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuYWRkUmVxdWVzdChyZXEsIGNvbm5lY3RPcHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW0lOVEVSTkFMXS5jdXJyZW50U29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgY3JlYXRlU29ja2V0KClgIGlzbid0IGRlZmluZWQgaW4gYEB0eXBlcy9ub2RlYFxuICAgICAgICAgICAgc3VwZXIuY3JlYXRlU29ja2V0KHJlcSwgb3B0aW9ucywgY2IpO1xuICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlY3JlbWVudFNvY2tldHMobmFtZSwgZmFrZVNvY2tldCk7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpc1tJTlRFUk5BTF0uY3VycmVudFNvY2tldDtcbiAgICAgICAgdGhpc1tJTlRFUk5BTF0uY3VycmVudFNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc29ja2V0IHdhcyByZXR1cm5lZCBpbiB0aGUgYGNvbm5lY3QoKWAgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgIH1cbiAgICBnZXQgZGVmYXVsdFBvcnQoKSB7XG4gICAgICAgIHJldHVybiAodGhpc1tJTlRFUk5BTF0uZGVmYXVsdFBvcnQgPz9cbiAgICAgICAgICAgICh0aGlzLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwKSk7XG4gICAgfVxuICAgIHNldCBkZWZhdWx0UG9ydCh2KSB7XG4gICAgICAgIGlmICh0aGlzW0lOVEVSTkFMXSkge1xuICAgICAgICAgICAgdGhpc1tJTlRFUk5BTF0uZGVmYXVsdFBvcnQgPSB2O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzW0lOVEVSTkFMXS5wcm90b2NvbCA/P1xuICAgICAgICAgICAgKHRoaXMuaXNTZWN1cmVFbmRwb2ludCgpID8gJ2h0dHBzOicgOiAnaHR0cDonKSk7XG4gICAgfVxuICAgIHNldCBwcm90b2NvbCh2KSB7XG4gICAgICAgIGlmICh0aGlzW0lOVEVSTkFMXSkge1xuICAgICAgICAgICAgdGhpc1tJTlRFUk5BTF0ucHJvdG9jb2wgPSB2O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BZ2VudCA9IEFnZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwiQWdlbnQiLCJuZXQiLCJyZXF1aXJlIiwiaHR0cCIsImh0dHBzXzEiLCJJTlRFUk5BTCIsIlN5bWJvbCIsImNvbnN0cnVjdG9yIiwib3B0cyIsImlzU2VjdXJlRW5kcG9pbnQiLCJvcHRpb25zIiwic2VjdXJlRW5kcG9pbnQiLCJwcm90b2NvbCIsInN0YWNrIiwiRXJyb3IiLCJzcGxpdCIsInNvbWUiLCJsIiwiaW5kZXhPZiIsImluY3JlbWVudFNvY2tldHMiLCJuYW1lIiwibWF4U29ja2V0cyIsIkluZmluaXR5IiwibWF4VG90YWxTb2NrZXRzIiwic29ja2V0cyIsImZha2VTb2NrZXQiLCJTb2NrZXQiLCJwdXNoIiwidG90YWxTb2NrZXRDb3VudCIsImRlY3JlbWVudFNvY2tldHMiLCJzb2NrZXQiLCJpbmRleCIsInNwbGljZSIsImxlbmd0aCIsImdldE5hbWUiLCJjcmVhdGVTb2NrZXQiLCJyZXEiLCJjYiIsImNvbm5lY3RPcHRzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiY29ubmVjdCIsImFkZFJlcXVlc3QiLCJlcnIiLCJjdXJyZW50U29ja2V0IiwiY3JlYXRlQ29ubmVjdGlvbiIsImRlZmF1bHRQb3J0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/https-proxy-agent/node_modules/agent-base/dist/index.js\n");

/***/ })

};
;