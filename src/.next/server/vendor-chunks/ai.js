"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2F6dXJlLW9wZW4tYWktYWNjZWxlcmF0b3IvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzPzVlMzQiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIGxldCBpID0gc2l6ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlkICs9IGFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoKSB8IDBdXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG59XG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSAnJ1xuICBsZXQgaSA9IHNpemVcbiAgd2hpbGUgKGktLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogNjQpIHwgMF1cbiAgfVxuICByZXR1cm4gaWRcbn1cbmV4cG9ydCB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n'use client'\n\n// react/use-chat.ts\n;\n\n\n// shared/utils.ts\n\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7\n);\nfunction createChunkDecoder(complex) {\n  const decoder = new TextDecoder();\n  if (!complex) {\n    return function(chunk) {\n      if (!chunk)\n        return \"\";\n      return decoder.decode(chunk, { stream: true });\n    };\n  }\n  return function(chunk) {\n    const decoded = decoder.decode(chunk, { stream: true }).split(\"\\n\").filter((line) => line !== \"\");\n    return decoded.map(getStreamStringTypeAndValue).filter(Boolean);\n  };\n}\nvar StreamStringPrefixes = {\n  text: 0,\n  function_call: 1,\n  data: 2\n  // user_err: 3?\n};\nvar getStreamStringTypeAndValue = (line) => {\n  const firstSeperatorIndex = line.indexOf(\":\");\n  const prefix = line.slice(0, firstSeperatorIndex);\n  const type = Object.keys(StreamStringPrefixes).find(\n    (key) => StreamStringPrefixes[key] === Number(prefix)\n  );\n  const val = line.slice(firstSeperatorIndex + 1);\n  let parsedVal = val;\n  if (!val) {\n    return { type, value: \"\" };\n  }\n  try {\n    parsedVal = JSON.parse(val);\n  } catch (e) {\n    console.error(\"Failed to parse JSON value:\", val);\n  }\n  return { type, value: parsedVal };\n};\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n\n// react/parseComplexResponse.ts\nasync function parseComplexResponse({\n  reader,\n  abortControllerRef,\n  update\n}) {\n  const decode = createChunkDecoder(true);\n  const createdAt = /* @__PURE__ */ new Date();\n  const prefixMap = {};\n  const NEWLINE = \"\\n\".charCodeAt(0);\n  let chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    let concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks) {\n      concatenatedChunks.set(chunk, offset);\n      offset += chunk.length;\n    }\n    chunks.length = 0;\n    totalLength = 0;\n    const lines = decode(concatenatedChunks);\n    if (typeof lines === \"string\") {\n      throw new Error(\n        \"Invalid response format. Complex mode was set but the response is a string. This should never happen.\"\n      );\n    }\n    for (const { type, value: value2 } of lines) {\n      if (type === \"text\") {\n        if (prefixMap[\"text\"]) {\n          prefixMap[\"text\"] = {\n            ...prefixMap[\"text\"],\n            content: (prefixMap[\"text\"].content || \"\") + value2\n          };\n        } else {\n          prefixMap[\"text\"] = {\n            id: nanoid(),\n            role: \"assistant\",\n            content: value2,\n            createdAt\n          };\n        }\n      }\n      let functionCallMessage = null;\n      if (type === \"function_call\") {\n        prefixMap[\"function_call\"] = value2;\n        let functionCall = prefixMap[\"function_call\"];\n        if (functionCall && typeof functionCall === \"string\") {\n          const parsedFunctionCall = JSON.parse(\n            functionCall\n          ).function_call;\n          functionCallMessage = {\n            id: nanoid(),\n            role: \"assistant\",\n            content: \"\",\n            function_call: parsedFunctionCall,\n            name: parsedFunctionCall.name,\n            createdAt\n          };\n          prefixMap[\"function_call\"] = functionCallMessage;\n        }\n      }\n      if (type === \"data\") {\n        const parsedValue = JSON.parse(value2);\n        if (prefixMap[\"data\"]) {\n          prefixMap[\"data\"] = [...prefixMap[\"data\"], ...parsedValue];\n        } else {\n          prefixMap[\"data\"] = parsedValue;\n        }\n      }\n      const data = prefixMap[\"data\"];\n      const responseMessage = prefixMap[\"text\"];\n      const merged = [functionCallMessage, responseMessage].filter(\n        Boolean\n      );\n      update(merged, data);\n      if (abortControllerRef.current === null) {\n        reader.cancel();\n        break;\n      }\n    }\n  }\n  return prefixMap;\n}\n\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, onFinish, onResponse, sendExtraMessageFields) => {\n  var _a, _b;\n  const previousMessages = messagesRef.current;\n  mutate(chatRequest.messages, false);\n  const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call }) => ({\n    role,\n    content,\n    ...name !== void 0 && { name },\n    ...function_call !== void 0 && {\n      function_call\n    }\n  }));\n  if (typeof api !== \"string\") {\n    const replyId = nanoid();\n    const createdAt = /* @__PURE__ */ new Date();\n    let responseMessage = {\n      id: replyId,\n      createdAt,\n      content: \"\",\n      role: \"assistant\"\n    };\n    async function readRow(promise) {\n      const { content, ui, next } = await promise;\n      responseMessage[\"content\"] = content;\n      responseMessage[\"ui\"] = await ui;\n      mutate([...chatRequest.messages, { ...responseMessage }], false);\n      if (next) {\n        await readRow(next);\n      }\n    }\n    try {\n      const promise = api({\n        messages: constructedMessagesPayload\n      });\n      await readRow(promise);\n    } catch (e) {\n      mutate(previousMessages, false);\n      throw e;\n    }\n    if (onFinish) {\n      onFinish(responseMessage);\n    }\n    return responseMessage;\n  }\n  const res = await fetch(api, {\n    method: \"POST\",\n    body: JSON.stringify({\n      messages: constructedMessagesPayload,\n      ...extraMetadataRef.current.body,\n      ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n      ...chatRequest.functions !== void 0 && {\n        functions: chatRequest.functions\n      },\n      ...chatRequest.function_call !== void 0 && {\n        function_call: chatRequest.function_call\n      }\n    }),\n    credentials: extraMetadataRef.current.credentials,\n    headers: {\n      ...extraMetadataRef.current.headers,\n      ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n    },\n    ...abortControllerRef.current !== null && {\n      signal: abortControllerRef.current.signal\n    }\n  }).catch((err) => {\n    mutate(previousMessages, false);\n    throw err;\n  });\n  if (onResponse) {\n    try {\n      await onResponse(res);\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (!res.ok) {\n    mutate(previousMessages, false);\n    throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n  }\n  if (!res.body) {\n    throw new Error(\"The response body is empty.\");\n  }\n  const isComplexMode = res.headers.get(COMPLEX_HEADER) === \"true\";\n  let responseMessages = [];\n  const reader = res.body.getReader();\n  let responseData = [];\n  if (isComplexMode) {\n    const prefixMap = await parseComplexResponse({\n      reader,\n      abortControllerRef,\n      update(merged, data) {\n        mutate([...chatRequest.messages, ...merged], false);\n        mutateStreamData([...existingData || [], ...data || []], false);\n      }\n    });\n    for (const [type, item] of Object.entries(prefixMap)) {\n      if (onFinish && type === \"text\") {\n        onFinish(item);\n      }\n      if (type === \"data\") {\n        responseData.push(item);\n      } else {\n        responseMessages.push(item);\n      }\n    }\n    return { messages: responseMessages, data: responseData };\n  } else {\n    const createdAt = /* @__PURE__ */ new Date();\n    const decode = createChunkDecoder(false);\n    let streamedResponse = \"\";\n    const replyId = nanoid();\n    let responseMessage = {\n      id: replyId,\n      createdAt,\n      content: \"\",\n      role: \"assistant\"\n    };\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        break;\n      }\n      streamedResponse += decode(value);\n      if (streamedResponse.startsWith('{\"function_call\":')) {\n        responseMessage[\"function_call\"] = streamedResponse;\n      } else {\n        responseMessage[\"content\"] = streamedResponse;\n      }\n      mutate([...chatRequest.messages, { ...responseMessage }], false);\n      if (abortControllerRef.current === null) {\n        reader.cancel();\n        break;\n      }\n    }\n    if (streamedResponse.startsWith('{\"function_call\":')) {\n      const parsedFunctionCall = JSON.parse(streamedResponse).function_call;\n      responseMessage[\"function_call\"] = parsedFunctionCall;\n      mutate([...chatRequest.messages, { ...responseMessage }]);\n    }\n    if (onFinish) {\n      onFinish(responseMessage);\n    }\n    return responseMessage;\n  }\n};\nfunction useChat({\n  api = \"/api/chat\",\n  id,\n  initialMessages = [],\n  initialInput = \"\",\n  sendExtraMessageFields,\n  experimental_onFunctionCall,\n  onResponse,\n  onFinish,\n  onError,\n  credentials,\n  headers,\n  body\n} = {}) {\n  const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n  const chatId = id || hookId;\n  const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([api, chatId], null, {\n    fallbackData: initialMessages\n  });\n  const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n    [chatId, \"loading\"],\n    null\n  );\n  const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n    [chatId, \"streamData\"],\n    null\n  );\n  const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    messagesRef.current = messages || [];\n  }, [messages]);\n  const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    credentials,\n    headers,\n    body\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body\n    };\n  }, [credentials, headers, body]);\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (chatRequest) => {\n      try {\n        mutateLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        abortControllerRef.current = abortController;\n        while (true) {\n          const messagesAndDataOrJustMessage = await getStreamedResponse(\n            api,\n            chatRequest,\n            mutate,\n            mutateStreamData,\n            streamData,\n            extraMetadataRef,\n            messagesRef,\n            abortControllerRef,\n            onFinish,\n            onResponse,\n            sendExtraMessageFields\n          );\n          if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages) {\n              if (message.function_call === void 0 || typeof message.function_call === \"string\") {\n                continue;\n              }\n              hasFollowingResponse = true;\n              if (experimental_onFunctionCall) {\n                const functionCall = message.function_call;\n                const functionCallResponse = await experimental_onFunctionCall(\n                  messagesRef.current,\n                  functionCall\n                );\n                if (functionCallResponse === void 0) {\n                  hasFollowingResponse = false;\n                  break;\n                }\n                chatRequest = functionCallResponse;\n              }\n            }\n            if (!hasFollowingResponse) {\n              break;\n            }\n          } else {\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if (streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") {\n              break;\n            }\n            if (experimental_onFunctionCall) {\n              const functionCall = streamedResponseMessage.function_call;\n              const functionCallResponse = await experimental_onFunctionCall(\n                messagesRef.current,\n                functionCall\n              );\n              if (functionCallResponse === void 0)\n                break;\n              chatRequest = functionCallResponse;\n            }\n          }\n        }\n        abortControllerRef.current = null;\n      } catch (err) {\n        if (err.name === \"AbortError\") {\n          abortControllerRef.current = null;\n          return null;\n        }\n        if (onError && err instanceof Error) {\n          onError(err);\n        }\n        setError(err);\n      } finally {\n        mutateLoading(false);\n      }\n    },\n    [\n      mutate,\n      mutateLoading,\n      api,\n      extraMetadataRef,\n      onResponse,\n      onFinish,\n      onError,\n      setError,\n      mutateStreamData,\n      streamData,\n      sendExtraMessageFields,\n      experimental_onFunctionCall,\n      messagesRef.current,\n      abortControllerRef.current\n    ]\n  );\n  const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (message, { options, functions, function_call } = {}) => {\n      if (!message.id) {\n        message.id = nanoid();\n      }\n      const chatRequest = {\n        messages: messagesRef.current.concat(message),\n        options,\n        ...functions !== void 0 && { functions },\n        ...function_call !== void 0 && { function_call }\n      };\n      return triggerRequest(chatRequest);\n    },\n    [triggerRequest]\n  );\n  const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async ({ options, functions, function_call } = {}) => {\n      if (messagesRef.current.length === 0)\n        return null;\n      const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n      if (lastMessage.role === \"assistant\") {\n        const chatRequest2 = {\n          messages: messagesRef.current.slice(0, -1),\n          options,\n          ...functions !== void 0 && { functions },\n          ...function_call !== void 0 && { function_call }\n        };\n        return triggerRequest(chatRequest2);\n      }\n      const chatRequest = {\n        messages: messagesRef.current,\n        options,\n        ...functions !== void 0 && { functions },\n        ...function_call !== void 0 && { function_call }\n      };\n      return triggerRequest(chatRequest);\n    },\n    [triggerRequest]\n  );\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n  const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (messages2) => {\n      mutate(messages2, false);\n      messagesRef.current = messages2;\n    },\n    [mutate]\n  );\n  const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n  const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (e, { options, functions, function_call } = {}, metadata) => {\n      if (metadata) {\n        extraMetadataRef.current = {\n          ...extraMetadataRef.current,\n          ...metadata\n        };\n      }\n      e.preventDefault();\n      if (!input)\n        return;\n      append(\n        {\n          content: input,\n          role: \"user\",\n          createdAt: /* @__PURE__ */ new Date()\n        },\n        { options, functions, function_call }\n      );\n      setInput(\"\");\n    },\n    [input, append]\n  );\n  const handleInputChange = (e) => {\n    setInput(e.target.value);\n  };\n  return {\n    messages: messages || [],\n    error,\n    append,\n    reload,\n    stop,\n    setMessages,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    data: streamData\n  };\n}\n\n// react/use-completion.ts\n\n\nfunction useCompletion({\n  api = \"/api/completion\",\n  id,\n  initialCompletion = \"\",\n  initialInput = \"\",\n  credentials,\n  headers,\n  body,\n  onResponse,\n  onFinish,\n  onError\n} = {}) {\n  const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n  const completionId = id || hookId;\n  const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([api, completionId], null, {\n    fallbackData: initialCompletion\n  });\n  const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n    [completionId, \"loading\"],\n    null\n  );\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n  const completion = data;\n  const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    credentials,\n    headers,\n    body\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body\n    };\n  }, [credentials, headers, body]);\n  const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (prompt, options) => {\n      try {\n        mutateLoading(true);\n        setError(void 0);\n        const abortController2 = new AbortController();\n        setAbortController(abortController2);\n        mutate(\"\", false);\n        const res = await fetch(api, {\n          method: \"POST\",\n          body: JSON.stringify({\n            prompt,\n            ...extraMetadataRef.current.body,\n            ...options == null ? void 0 : options.body\n          }),\n          credentials: extraMetadataRef.current.credentials,\n          headers: {\n            ...extraMetadataRef.current.headers,\n            ...options == null ? void 0 : options.headers\n          },\n          signal: abortController2.signal\n        }).catch((err) => {\n          throw err;\n        });\n        if (onResponse) {\n          try {\n            await onResponse(res);\n          } catch (err) {\n            throw err;\n          }\n        }\n        if (!res.ok) {\n          throw new Error(\n            await res.text() || \"Failed to fetch the chat response.\"\n          );\n        }\n        if (!res.body) {\n          throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        const decoder = createChunkDecoder();\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            break;\n          }\n          result += decoder(value);\n          mutate(result, false);\n          if (abortController2 === null) {\n            reader.cancel();\n            break;\n          }\n        }\n        if (onFinish) {\n          onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n      } catch (err) {\n        if (err.name === \"AbortError\") {\n          setAbortController(null);\n          return null;\n        }\n        if (err instanceof Error) {\n          if (onError) {\n            onError(err);\n          }\n        }\n        setError(err);\n      } finally {\n        mutateLoading(false);\n      }\n    },\n    [\n      mutate,\n      mutateLoading,\n      api,\n      extraMetadataRef,\n      setAbortController,\n      onResponse,\n      onFinish,\n      onError,\n      setError\n    ]\n  );\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (abortController) {\n      abortController.abort();\n      setAbortController(null);\n    }\n  }, [abortController]);\n  const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (completion2) => {\n      mutate(completion2, false);\n    },\n    [mutate]\n  );\n  const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (prompt, options) => {\n      return triggerRequest(prompt, options);\n    },\n    [triggerRequest]\n  );\n  const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n  const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (e) => {\n      e.preventDefault();\n      if (!input)\n        return;\n      return complete(input);\n    },\n    [input, complete]\n  );\n  const handleInputChange = (e) => {\n    setInput(e.target.value);\n  };\n  return {\n    completion,\n    complete,\n    error,\n    setCompletion,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBLENBQXdFO0FBQy9DOztBQUV6QjtBQUNtRDtBQUNuRCxhQUFhLGlFQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9henVyZS1vcGVuLWFpLWFjY2VsZXJhdG9yLy4vbm9kZV9tb2R1bGVzL2FpL3JlYWN0L2Rpc3QvaW5kZXgubWpzPzcwNzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIHJlYWN0L3VzZS1jaGF0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUiBmcm9tIFwic3dyXCI7XG5cbi8vIHNoYXJlZC91dGlscy50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcbnZhciBuYW5vaWQgPSBjdXN0b21BbHBoYWJldChcbiAgXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICA3XG4pO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKGNvbXBsZXgpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBpZiAoIWNvbXBsZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIGlmICghY2h1bmspXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKTtcbiAgICByZXR1cm4gZGVjb2RlZC5tYXAoZ2V0U3RyZWFtU3RyaW5nVHlwZUFuZFZhbHVlKS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG59XG52YXIgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIHRleHQ6IDAsXG4gIGZ1bmN0aW9uX2NhbGw6IDEsXG4gIGRhdGE6IDJcbiAgLy8gdXNlcl9lcnI6IDM/XG59O1xudmFyIGdldFN0cmVhbVN0cmluZ1R5cGVBbmRWYWx1ZSA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwZXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwZXJhdG9ySW5kZXgpO1xuICBjb25zdCB0eXBlID0gT2JqZWN0LmtleXMoU3RyZWFtU3RyaW5nUHJlZml4ZXMpLmZpbmQoXG4gICAgKGtleSkgPT4gU3RyZWFtU3RyaW5nUHJlZml4ZXNba2V5XSA9PT0gTnVtYmVyKHByZWZpeClcbiAgKTtcbiAgY29uc3QgdmFsID0gbGluZS5zbGljZShmaXJzdFNlcGVyYXRvckluZGV4ICsgMSk7XG4gIGxldCBwYXJzZWRWYWwgPSB2YWw7XG4gIGlmICghdmFsKSB7XG4gICAgcmV0dXJuIHsgdHlwZSwgdmFsdWU6IFwiXCIgfTtcbiAgfVxuICB0cnkge1xuICAgIHBhcnNlZFZhbCA9IEpTT04ucGFyc2UodmFsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgSlNPTiB2YWx1ZTpcIiwgdmFsKTtcbiAgfVxuICByZXR1cm4geyB0eXBlLCB2YWx1ZTogcGFyc2VkVmFsIH07XG59O1xudmFyIENPTVBMRVhfSEVBREVSID0gXCJYLUV4cGVyaW1lbnRhbC1TdHJlYW0tRGF0YVwiO1xuXG4vLyByZWFjdC9wYXJzZUNvbXBsZXhSZXNwb25zZS50c1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICByZWFkZXIsXG4gIGFib3J0Q29udHJvbGxlclJlZixcbiAgdXBkYXRlXG59KSB7XG4gIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2Rlcih0cnVlKTtcbiAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIGNvbnN0IHByZWZpeE1hcCA9IHt9O1xuICBjb25zdCBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuICBsZXQgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IGxpbmVzID0gZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcyk7XG4gICAgaWYgKHR5cGVvZiBsaW5lcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0LiBDb21wbGV4IG1vZGUgd2FzIHNldCBidXQgdGhlIHJlc3BvbnNlIGlzIGEgc3RyaW5nLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyB0eXBlLCB2YWx1ZTogdmFsdWUyIH0gb2YgbGluZXMpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInRleHRcIikge1xuICAgICAgICBpZiAocHJlZml4TWFwW1widGV4dFwiXSkge1xuICAgICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgICAuLi5wcmVmaXhNYXBbXCJ0ZXh0XCJdLFxuICAgICAgICAgICAgY29udGVudDogKHByZWZpeE1hcFtcInRleHRcIl0uY29udGVudCB8fCBcIlwiKSArIHZhbHVlMlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICAgIGlkOiBuYW5vaWQoKSxcbiAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICBjb250ZW50OiB2YWx1ZTIsXG4gICAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IG51bGw7XG4gICAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIpIHtcbiAgICAgICAgcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHZhbHVlMjtcbiAgICAgICAgbGV0IGZ1bmN0aW9uQ2FsbCA9IHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl07XG4gICAgICAgIGlmIChmdW5jdGlvbkNhbGwgJiYgdHlwZW9mIGZ1bmN0aW9uQ2FsbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZEZ1bmN0aW9uQ2FsbCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICBmdW5jdGlvbkNhbGxcbiAgICAgICAgICApLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGlkOiBuYW5vaWQoKSxcbiAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogcGFyc2VkRnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgbmFtZTogcGFyc2VkRnVuY3Rpb25DYWxsLm5hbWUsXG4gICAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl0gPSBmdW5jdGlvbkNhbGxNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlMik7XG4gICAgICAgIGlmIChwcmVmaXhNYXBbXCJkYXRhXCJdKSB7XG4gICAgICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXSA9IFsuLi5wcmVmaXhNYXBbXCJkYXRhXCJdLCAuLi5wYXJzZWRWYWx1ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXSA9IHBhcnNlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gcHJlZml4TWFwW1wiZGF0YVwiXTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFtcInRleHRcIl07XG4gICAgICBjb25zdCBtZXJnZWQgPSBbZnVuY3Rpb25DYWxsTWVzc2FnZSwgcmVzcG9uc2VNZXNzYWdlXS5maWx0ZXIoXG4gICAgICAgIEJvb2xlYW5cbiAgICAgICk7XG4gICAgICB1cGRhdGUobWVyZ2VkLCBkYXRhKTtcbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcHJlZml4TWFwO1xufVxuXG4vLyByZWFjdC91c2UtY2hhdC50c1xudmFyIGdldFN0cmVhbWVkUmVzcG9uc2UgPSBhc3luYyAoYXBpLCBjaGF0UmVxdWVzdCwgbXV0YXRlLCBtdXRhdGVTdHJlYW1EYXRhLCBleGlzdGluZ0RhdGEsIGV4dHJhTWV0YWRhdGFSZWYsIG1lc3NhZ2VzUmVmLCBhYm9ydENvbnRyb2xsZXJSZWYsIG9uRmluaXNoLCBvblJlc3BvbnNlLCBzZW5kRXh0cmFNZXNzYWdlRmllbGRzKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHByZXZpb3VzTWVzc2FnZXMgPSBtZXNzYWdlc1JlZi5jdXJyZW50O1xuICBtdXRhdGUoY2hhdFJlcXVlc3QubWVzc2FnZXMsIGZhbHNlKTtcbiAgY29uc3QgY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQgPSBzZW5kRXh0cmFNZXNzYWdlRmllbGRzID8gY2hhdFJlcXVlc3QubWVzc2FnZXMgOiBjaGF0UmVxdWVzdC5tZXNzYWdlcy5tYXAoKHsgcm9sZSwgY29udGVudCwgbmFtZSwgZnVuY3Rpb25fY2FsbCB9KSA9PiAoe1xuICAgIHJvbGUsXG4gICAgY29udGVudCxcbiAgICAuLi5uYW1lICE9PSB2b2lkIDAgJiYgeyBuYW1lIH0sXG4gICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHtcbiAgICAgIGZ1bmN0aW9uX2NhbGxcbiAgICB9XG4gIH0pKTtcbiAgaWYgKHR5cGVvZiBhcGkgIT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCByZXBseUlkID0gbmFub2lkKCk7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHtcbiAgICAgIGlkOiByZXBseUlkLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgY29udGVudDogXCJcIixcbiAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCJcbiAgICB9O1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRSb3cocHJvbWlzZSkge1xuICAgICAgY29uc3QgeyBjb250ZW50LCB1aSwgbmV4dCB9ID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgIHJlc3BvbnNlTWVzc2FnZVtcImNvbnRlbnRcIl0gPSBjb250ZW50O1xuICAgICAgcmVzcG9uc2VNZXNzYWdlW1widWlcIl0gPSBhd2FpdCB1aTtcbiAgICAgIG11dGF0ZShbLi4uY2hhdFJlcXVlc3QubWVzc2FnZXMsIHsgLi4ucmVzcG9uc2VNZXNzYWdlIH1dLCBmYWxzZSk7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBhd2FpdCByZWFkUm93KG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvbWlzZSA9IGFwaSh7XG4gICAgICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZFxuICAgICAgfSk7XG4gICAgICBhd2FpdCByZWFkUm93KHByb21pc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG11dGF0ZShwcmV2aW91c01lc3NhZ2VzLCBmYWxzZSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZU1lc3NhZ2U7XG4gIH1cbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBtZXNzYWdlczogY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQsXG4gICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgIC4uLihfYSA9IGNoYXRSZXF1ZXN0Lm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5ib2R5LFxuICAgICAgLi4uY2hhdFJlcXVlc3QuZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYge1xuICAgICAgICBmdW5jdGlvbnM6IGNoYXRSZXF1ZXN0LmZ1bmN0aW9uc1xuICAgICAgfSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0LmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7XG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IGNoYXRSZXF1ZXN0LmZ1bmN0aW9uX2NhbGxcbiAgICAgIH1cbiAgICB9KSxcbiAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLFxuICAgICAgLi4uKF9iID0gY2hhdFJlcXVlc3Qub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhlYWRlcnNcbiAgICB9LFxuICAgIC4uLmFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ICE9PSBudWxsICYmIHtcbiAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuc2lnbmFsXG4gICAgfVxuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuICBpZiAob25SZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvblJlc3BvbnNlKHJlcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGlmICghcmVzLm9rKSB7XG4gICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgcmVzLnRleHQoKSB8fCBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIik7XG4gIH1cbiAgaWYgKCFyZXMuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgfVxuICBjb25zdCBpc0NvbXBsZXhNb2RlID0gcmVzLmhlYWRlcnMuZ2V0KENPTVBMRVhfSEVBREVSKSA9PT0gXCJ0cnVlXCI7XG4gIGxldCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuICBsZXQgcmVzcG9uc2VEYXRhID0gW107XG4gIGlmIChpc0NvbXBsZXhNb2RlKSB7XG4gICAgY29uc3QgcHJlZml4TWFwID0gYXdhaXQgcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICAgICAgcmVhZGVyLFxuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgdXBkYXRlKG1lcmdlZCwgZGF0YSkge1xuICAgICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCAuLi5tZXJnZWRdLCBmYWxzZSk7XG4gICAgICAgIG11dGF0ZVN0cmVhbURhdGEoWy4uLmV4aXN0aW5nRGF0YSB8fCBbXSwgLi4uZGF0YSB8fCBbXV0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyhwcmVmaXhNYXApKSB7XG4gICAgICBpZiAob25GaW5pc2ggJiYgdHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgb25GaW5pc2goaXRlbSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgcmVzcG9uc2VEYXRhLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2VzOiByZXNwb25zZU1lc3NhZ2VzLCBkYXRhOiByZXNwb25zZURhdGEgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoZmFsc2UpO1xuICAgIGxldCBzdHJlYW1lZFJlc3BvbnNlID0gXCJcIjtcbiAgICBjb25zdCByZXBseUlkID0gbmFub2lkKCk7XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHtcbiAgICAgIGlkOiByZXBseUlkLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgY29udGVudDogXCJcIixcbiAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCJcbiAgICB9O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdHJlYW1lZFJlc3BvbnNlICs9IGRlY29kZSh2YWx1ZSk7XG4gICAgICBpZiAoc3RyZWFtZWRSZXNwb25zZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykpIHtcbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHN0cmVhbWVkUmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZU1lc3NhZ2VbXCJjb250ZW50XCJdID0gc3RyZWFtZWRSZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIG11dGF0ZShbLi4uY2hhdFJlcXVlc3QubWVzc2FnZXMsIHsgLi4ucmVzcG9uc2VNZXNzYWdlIH1dLCBmYWxzZSk7XG4gICAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpKSB7XG4gICAgICBjb25zdCBwYXJzZWRGdW5jdGlvbkNhbGwgPSBKU09OLnBhcnNlKHN0cmVhbWVkUmVzcG9uc2UpLmZ1bmN0aW9uX2NhbGw7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJmdW5jdGlvbl9jYWxsXCJdID0gcGFyc2VkRnVuY3Rpb25DYWxsO1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgeyAuLi5yZXNwb25zZU1lc3NhZ2UgfV0pO1xuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZU1lc3NhZ2U7XG4gIH1cbn07XG5mdW5jdGlvbiB1c2VDaGF0KHtcbiAgYXBpID0gXCIvYXBpL2NoYXRcIixcbiAgaWQsXG4gIGluaXRpYWxNZXNzYWdlcyA9IFtdLFxuICBpbml0aWFsSW5wdXQgPSBcIlwiLFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keVxufSA9IHt9KSB7XG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IGNoYXRJZCA9IGlkIHx8IGhvb2tJZDtcbiAgY29uc3QgeyBkYXRhOiBtZXNzYWdlcywgbXV0YXRlIH0gPSB1c2VTV1IoW2FwaSwgY2hhdElkXSwgbnVsbCwge1xuICAgIGZhbGxiYWNrRGF0YTogaW5pdGlhbE1lc3NhZ2VzXG4gIH0pO1xuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUihcbiAgICBbY2hhdElkLCBcImxvYWRpbmdcIl0sXG4gICAgbnVsbFxuICApO1xuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSKFxuICAgIFtjaGF0SWQsIFwic3RyZWFtRGF0YVwiXSxcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IG1lc3NhZ2VzUmVmID0gdXNlUmVmKG1lc3NhZ2VzIHx8IFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBtZXNzYWdlc1JlZi5jdXJyZW50ID0gbWVzc2FnZXMgfHwgW107XG4gIH0sIFttZXNzYWdlc10pO1xuICBjb25zdCBhYm9ydENvbnRyb2xsZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGV4dHJhTWV0YWRhdGFSZWYgPSB1c2VSZWYoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUoKTtcbiAgY29uc3QgdHJpZ2dlclJlcXVlc3QgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoY2hhdFJlcXVlc3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSA9IGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UoXG4gICAgICAgICAgICBhcGksXG4gICAgICAgICAgICBjaGF0UmVxdWVzdCxcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICAgICAgICBzdHJlYW1EYXRhLFxuICAgICAgICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgICAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgICAgICAgb25GaW5pc2gsXG4gICAgICAgICAgICBvblJlc3BvbnNlLFxuICAgICAgICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFwibWVzc2FnZXNcIiBpbiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlKSB7XG4gICAgICAgICAgICBsZXQgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCB8fCB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhdFJlcXVlc3QgPSBmdW5jdGlvbkNhbGxSZXNwb25zZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNGb2xsb3dpbmdSZXNwb25zZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlO1xuICAgICAgICAgICAgaWYgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCB8fCB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB2b2lkIDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNoYXRSZXF1ZXN0ID0gZnVuY3Rpb25DYWxsUmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkVycm9yICYmIGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHNldEVycm9yKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yLFxuICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICAgIHN0cmVhbURhdGEsXG4gICAgICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50XG4gICAgXVxuICApO1xuICBjb25zdCBhcHBlbmQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAobWVzc2FnZSwgeyBvcHRpb25zLCBmdW5jdGlvbnMsIGZ1bmN0aW9uX2NhbGwgfSA9IHt9KSA9PiB7XG4gICAgICBpZiAoIW1lc3NhZ2UuaWQpIHtcbiAgICAgICAgbWVzc2FnZS5pZCA9IG5hbm9pZCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LmNvbmNhdChtZXNzYWdlKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHsgb3B0aW9ucywgZnVuY3Rpb25zLCBmdW5jdGlvbl9jYWxsIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2VzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNSZWYuY3VycmVudFttZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RNZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICAgICAgY29uc3QgY2hhdFJlcXVlc3QyID0ge1xuICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LnNsaWNlKDAsIC0xKSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIC4uLmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25zIH0sXG4gICAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdDIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAuLi5mdW5jdGlvbnMgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9ucyB9LFxuICAgICAgICAuLi5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbl9jYWxsIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0XVxuICApO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuYWJvcnQoKTtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2V0TWVzc2FnZXMgPSB1c2VDYWxsYmFjayhcbiAgICAobWVzc2FnZXMyKSA9PiB7XG4gICAgICBtdXRhdGUobWVzc2FnZXMyLCBmYWxzZSk7XG4gICAgICBtZXNzYWdlc1JlZi5jdXJyZW50ID0gbWVzc2FnZXMyO1xuICAgIH0sXG4gICAgW211dGF0ZV1cbiAgKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShpbml0aWFsSW5wdXQpO1xuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjayhcbiAgICAoZSwgeyBvcHRpb25zLCBmdW5jdGlvbnMsIGZ1bmN0aW9uX2NhbGwgfSA9IHt9LCBtZXRhZGF0YSkgPT4ge1xuICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghaW5wdXQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGFwcGVuZChcbiAgICAgICAge1xuICAgICAgICAgIGNvbnRlbnQ6IGlucHV0LFxuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNyZWF0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgfSxcbiAgICAgICAgeyBvcHRpb25zLCBmdW5jdGlvbnMsIGZ1bmN0aW9uX2NhbGwgfVxuICAgICAgKTtcbiAgICAgIHNldElucHV0KFwiXCIpO1xuICAgIH0sXG4gICAgW2lucHV0LCBhcHBlbmRdXG4gICk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGUpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VzIHx8IFtdLFxuICAgIGVycm9yLFxuICAgIGFwcGVuZCxcbiAgICByZWxvYWQsXG4gICAgc3RvcCxcbiAgICBzZXRNZXNzYWdlcyxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgaXNMb2FkaW5nLFxuICAgIGRhdGE6IHN0cmVhbURhdGFcbiAgfTtcbn1cblxuLy8gcmVhY3QvdXNlLWNvbXBsZXRpb24udHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZUlkIGFzIHVzZUlkMiwgdXNlUmVmIGFzIHVzZVJlZjIsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUjIgZnJvbSBcInN3clwiO1xuZnVuY3Rpb24gdXNlQ29tcGxldGlvbih7XG4gIGFwaSA9IFwiL2FwaS9jb21wbGV0aW9uXCIsXG4gIGlkLFxuICBpbml0aWFsQ29tcGxldGlvbiA9IFwiXCIsXG4gIGluaXRpYWxJbnB1dCA9IFwiXCIsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvclxufSA9IHt9KSB7XG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkMigpO1xuICBjb25zdCBjb21wbGV0aW9uSWQgPSBpZCB8fCBob29rSWQ7XG4gIGNvbnN0IHsgZGF0YSwgbXV0YXRlIH0gPSB1c2VTV1IyKFthcGksIGNvbXBsZXRpb25JZF0sIG51bGwsIHtcbiAgICBmYWxsYmFja0RhdGE6IGluaXRpYWxDb21wbGV0aW9uXG4gIH0pO1xuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUjIoXG4gICAgW2NvbXBsZXRpb25JZCwgXCJsb2FkaW5nXCJdLFxuICAgIG51bGxcbiAgKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTIodm9pZCAwKTtcbiAgY29uc3QgY29tcGxldGlvbiA9IGRhdGE7XG4gIGNvbnN0IFthYm9ydENvbnRyb2xsZXIsIHNldEFib3J0Q29udHJvbGxlcl0gPSB1c2VTdGF0ZTIobnVsbCk7XG4gIGNvbnN0IGV4dHJhTWV0YWRhdGFSZWYgPSB1c2VSZWYyKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHlcbiAgfSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcbiAgY29uc3QgdHJpZ2dlclJlcXVlc3QgPSB1c2VDYWxsYmFjazIoXG4gICAgYXN5bmMgKHByb21wdCwgb3B0aW9ucykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyMiA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcjIpO1xuICAgICAgICBtdXRhdGUoXCJcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5ib2R5XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3JlZGVudGlhbHM6IGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5jcmVkZW50aWFscyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVyc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIyLnNpZ25hbFxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgb25SZXNwb25zZShyZXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGF3YWl0IHJlcy50ZXh0KCkgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzLmJvZHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgICBtdXRhdGUocmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcjIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgICAgICBvbkZpbmlzaChwcm9tcHQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0RXJyb3IoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3JcbiAgICBdXG4gICk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIH1cbiAgfSwgW2Fib3J0Q29udHJvbGxlcl0pO1xuICBjb25zdCBzZXRDb21wbGV0aW9uID0gdXNlQ2FsbGJhY2syKFxuICAgIChjb21wbGV0aW9uMikgPT4ge1xuICAgICAgbXV0YXRlKGNvbXBsZXRpb24yLCBmYWxzZSk7XG4gICAgfSxcbiAgICBbbXV0YXRlXVxuICApO1xuICBjb25zdCBjb21wbGV0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QocHJvbXB0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZTIoaW5pdGlhbElucHV0KTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2syKFxuICAgIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KVxuICAgICAgICByZXR1cm47XG4gICAgICByZXR1cm4gY29tcGxldGUoaW5wdXQpO1xuICAgIH0sXG4gICAgW2lucHV0LCBjb21wbGV0ZV1cbiAgKTtcbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZSkgPT4ge1xuICAgIHNldElucHV0KGUudGFyZ2V0LnZhbHVlKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0aW9uLFxuICAgIGNvbXBsZXRlLFxuICAgIGVycm9yLFxuICAgIHNldENvbXBsZXRpb24sXG4gICAgc3RvcCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgaXNMb2FkaW5nXG4gIH07XG59XG5leHBvcnQge1xuICB1c2VDaGF0LFxuICB1c2VDb21wbGV0aW9uXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   COMPLEX_HEADER: () => (/* binding */ COMPLEX_HEADER),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   StreamStringPrefixes: () => (/* binding */ StreamStringPrefixes),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createChunkDecoder: () => (/* binding */ createChunkDecoder),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_StreamingReactResponse: () => (/* binding */ experimental_StreamingReactResponse),\n/* harmony export */   getStreamString: () => (/* binding */ getStreamString),\n/* harmony export */   getStreamStringTypeAndValue: () => (/* binding */ getStreamStringTypeAndValue),\n/* harmony export */   isStreamStringEqualToType: () => (/* binding */ isStreamStringEqualToType),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_0__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            controller.enqueue(textEncoder.encode(message));\n            aggregatedResponse += message;\n            if (callbacks.onToken) await callbacks.onToken(message);\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a;\n            await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n        }\n    });\n}\n// shared/utils.ts\n\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_1__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(getStreamStringTypeAndValue).filter(Boolean);\n    };\n}\nvar StreamStringPrefixes = {\n    text: 0,\n    function_call: 1,\n    data: 2\n};\nvar isStreamStringEqualToType = (type, value)=>value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith(\"\\n\");\nvar getStreamString = (type, value)=>`${StreamStringPrefixes[type]}:${JSON.stringify(value)}\n`;\nvar getStreamStringTypeAndValue = (line)=>{\n    const firstSeperatorIndex = line.indexOf(\":\");\n    const prefix = line.slice(0, firstSeperatorIndex);\n    const type = Object.keys(StreamStringPrefixes).find((key)=>StreamStringPrefixes[key] === Number(prefix));\n    const val = line.slice(firstSeperatorIndex + 1);\n    let parsedVal = val;\n    if (!val) {\n        return {\n            type,\n            value: \"\"\n        };\n    }\n    try {\n        parsedVal = JSON.parse(val);\n    } catch (e) {\n        console.error(\"Failed to parse JSON value:\", val);\n    }\n    return {\n        type,\n        value: parsedVal\n    };\n};\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// streams/stream-data.ts\nvar experimental_StreamData = class {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this.controller = null;\n        // closing the stream is synchronous, but we want to return a promise\n        // in case we're doing async work\n        this.isClosedPromise = null;\n        this.isClosedPromiseResolver = void 0;\n        this.isClosed = false;\n        // array to store appended data\n        this.data = [];\n        this.isClosedPromise = new Promise((resolve)=>{\n            this.isClosedPromiseResolver = resolve;\n        });\n        const self = this;\n        this.stream = new TransformStream({\n            start: async (controller)=>{\n                self.controller = controller;\n            },\n            transform: async (chunk, controller)=>{\n                if (self.data.length > 0) {\n                    const encodedData = self.encoder.encode(getStreamString(\"data\", JSON.stringify(self.data)));\n                    self.data = [];\n                    controller.enqueue(encodedData);\n                }\n                controller.enqueue(chunk);\n            },\n            async flush (controller) {\n                const warningTimeout =  true ? setTimeout(()=>{\n                    console.warn(\"The data stream is hanging. Did you forget to close it with `data.close()`?\");\n                }, 3e3) : 0;\n                await self.isClosedPromise;\n                if (warningTimeout !== null) {\n                    clearTimeout(warningTimeout);\n                }\n                if (self.data.length) {\n                    const encodedData = self.encoder.encode(getStreamString(\"data\", JSON.stringify(self.data)));\n                    controller.enqueue(encodedData);\n                }\n            }\n        });\n    }\n    async close() {\n        var _a;\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        (_a = this.isClosedPromiseResolver) == null ? void 0 : _a.call(this);\n        this.isClosed = true;\n    }\n    append(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        this.data.push(value);\n    }\n};\nfunction createStreamDataTransformer(experimental_streamData) {\n    if (!experimental_streamData) {\n        return new TransformStream({\n            transform: async (chunk, controller)=>{\n                controller.enqueue(chunk);\n            }\n        });\n    }\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode(getStreamString(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>{\n        return extract(JSON.parse(data));\n    };\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (const chunk of stream){\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n        if (isChatCompletionChunk(json) && ((_c = (_b = (_a = json.choices[0]) == null ? void 0 : _a.delta) == null ? void 0 : _b.function_call) == null ? void 0 : _c.name)) {\n            isFunctionStreamingIn = true;\n            return `{\"function_call\": {\"name\": \"${(_e = (_d = json.choices[0]) == null ? void 0 : _d.delta) == null ? void 0 : _e.function_call.name}\", \"arguments\": \"`;\n        } else if (isChatCompletionChunk(json) && ((_h = (_g = (_f = json.choices[0]) == null ? void 0 : _f.delta) == null ? void 0 : _g.function_call) == null ? void 0 : _h.arguments)) {\n            const argumentChunk = json.choices[0].delta.function_call.arguments;\n            let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n            return `${escapedPartialJson}`;\n        } else if (isFunctionStreamingIn && (((_i = json.choices[0]) == null ? void 0 : _i.finish_reason) === \"function_call\" || ((_j = json.choices[0]) == null ? void 0 : _j.finish_reason) === \"stop\")) {\n            isFunctionStreamingIn = false;\n            return '\"}}';\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && cb.experimental_onFunctionCall) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const isComplexMode = callbacks == null ? void 0 : callbacks.experimental_streamData;\n    const decode = createChunkDecoder();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && message.startsWith('{\"function_call\":');\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(isComplexMode ? textEncoder.encode(getStreamString(\"text\", message)) : chunk);\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                const isEndOfFunction = !isFirstChunk && callbacks.experimental_onFunctionCall && isFunctionStreamingIn;\n                if (isEndOfFunction && callbacks.experimental_onFunctionCall) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    const functionResponse = await callbacks.experimental_onFunctionCall({\n                        name: payload.function_call.name,\n                        arguments: argumentsPayload\n                    }, (result)=>{\n                        newFunctionCallMessages = [\n                            ...functionCallMessages,\n                            {\n                                role: \"assistant\",\n                                content: \"\",\n                                function_call: payload.function_call\n                            },\n                            {\n                                role: \"function\",\n                                name: payload.function_call.name,\n                                content: JSON.stringify(result)\n                            }\n                        ];\n                        return newFunctionCallMessages;\n                    });\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode(isComplexMode ? getStreamString(\"function_call\", aggregatedResponse) : aggregatedResponse));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(isComplexMode ? textEncoder.encode(getStreamString(\"text\", functionResponse)) : textEncoder.encode(functionResponse));\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n    constructor(res, init, data){\n        let processedStream = res;\n        if (data) {\n            processedStream = res.pipeThrough(data.stream);\n        }\n        super(processedStream, {\n            ...init,\n            status: 200,\n            headers: {\n                \"Content-Type\": \"text/plain; charset=utf-8\",\n                [COMPLEX_HEADER]: data ? \"true\" : \"false\",\n                ...init == null ? void 0 : init.headers\n            }\n        });\n    }\n};\nfunction streamToResponse(res, response, init) {\n    response.writeHead((init == null ? void 0 : init.status) || 200, {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        ...init == null ? void 0 : init.headers\n    });\n    const reader = res.getReader();\n    function read() {\n        reader.read().then(({ done, value })=>{\n            if (done) {\n                response.end();\n                return;\n            }\n            response.write(value);\n            read();\n        });\n    }\n    read();\n}\n// streams/huggingface-stream.ts\nfunction createParser2(res) {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    return new ReadableStream({\n        async pull (controller) {\n            var _a, _b;\n            const { value, done } = await res.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            const text = trimStartOfStream((_b = (_a = value.token) == null ? void 0 : _a.text) != null ? _b : \"\");\n            if (!text) return;\n            if (value.generated_text != null && value.generated_text.length > 0) {\n                controller.close();\n                return;\n            }\n            if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n                controller.close();\n            } else {\n                controller.enqueue(text);\n            }\n        }\n    });\n}\nfunction HuggingFaceStream(res, callbacks) {\n    return createParser2(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n}\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n    for (const line of lines){\n        const { text, is_finished } = JSON.parse(line);\n        if (!is_finished) {\n            controller.enqueue(text);\n        }\n    }\n}\nasync function readAndProcessLines(reader, controller) {\n    let segment = \"\";\n    while(true){\n        const { value: chunk, done } = await reader.read();\n        if (done) {\n            break;\n        }\n        segment += utf8Decoder.decode(chunk, {\n            stream: true\n        });\n        const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n        segment = linesArray.pop() || \"\";\n        await processLines(linesArray, controller);\n    }\n    if (segment) {\n        const linesArray = [\n            segment\n        ];\n        await processLines(linesArray, controller);\n    }\n    controller.close();\n}\nfunction createParser3(res) {\n    var _a;\n    const reader = (_a = res.body) == null ? void 0 : _a.getReader();\n    return new ReadableStream({\n        async start (controller) {\n            if (!reader) {\n                controller.close();\n                return;\n            }\n            await readAndProcessLines(reader, controller);\n        }\n    });\n}\nfunction CohereStream(reader, callbacks) {\n    return createParser3(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n}\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n    let previous = \"\";\n    return (data)=>{\n        const json = JSON.parse(data);\n        if (\"error\" in json) {\n            throw new Error(`${json.error.type}: ${json.error.message}`);\n        }\n        if (!(\"completion\" in json)) {\n            return;\n        }\n        const text = json.completion;\n        if (!previous || text.length > previous.length && text.startsWith(previous)) {\n            const delta = text.slice(previous.length);\n            previous = text;\n            return delta;\n        }\n        return text;\n    };\n}\nasync function* streamable2(stream) {\n    for await (const chunk of stream){\n        const text = chunk.completion;\n        if (text) yield text;\n    }\n}\nfunction AnthropicStream(res, cb) {\n    if (Symbol.asyncIterator in res) {\n        return readableFromAsyncIterable(streamable2(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n    } else {\n        return AIStream(res, parseAnthropicStream(), cb).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n    }\n}\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n    const runs = /* @__PURE__ */ new Set();\n    const handleError = async (e, runId)=>{\n        runs.delete(runId);\n        await writer.ready;\n        await writer.abort(e);\n    };\n    const handleStart = async (runId)=>{\n        runs.add(runId);\n    };\n    const handleEnd = async (runId)=>{\n        runs.delete(runId);\n        if (runs.size === 0) {\n            await writer.ready;\n            await writer.close();\n        }\n    };\n    return {\n        stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData)),\n        writer,\n        handlers: {\n            handleLLMNewToken: async (token)=>{\n                await writer.ready;\n                await writer.write(token);\n            },\n            handleLLMStart: async (_llm, _prompts, runId)=>{\n                handleStart(runId);\n            },\n            handleLLMEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleLLMError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleChainStart: async (_chain, _inputs, runId)=>{\n                handleStart(runId);\n            },\n            handleChainEnd: async (_outputs, runId)=>{\n                await handleEnd(runId);\n            },\n            handleChainError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleToolStart: async (_tool, _input, runId)=>{\n                handleStart(runId);\n            },\n            handleToolEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleToolError: async (e, runId)=>{\n                await handleError(e, runId);\n            }\n        }\n    };\n}\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb) {\n    var _a;\n    const url = (_a = res.urls) == null ? void 0 : _a.stream;\n    if (!url) {\n        if (res.error) throw new Error(res.error);\n        else throw new Error(\"Missing stream URL in Replicate response\");\n    }\n    const eventStream = await fetch(url, {\n        method: \"GET\",\n        headers: {\n            Accept: \"text/event-stream\"\n        }\n    });\n    return AIStream(eventStream, void 0, cb).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n}\n// streams/streaming-react-response.ts\nvar experimental_StreamingReactResponse = class {\n    constructor(res, options){\n        let resolveFunc = ()=>{};\n        let next = new Promise((resolve)=>{\n            resolveFunc = resolve;\n        });\n        let content = \"\";\n        const decode = createChunkDecoder();\n        const reader = res.getReader();\n        async function readChunk() {\n            var _a;\n            const { done, value } = await reader.read();\n            if (!done) {\n                content += decode(value);\n            }\n            const ui = ((_a = options == null ? void 0 : options.ui) == null ? void 0 : _a.call(options, {\n                content\n            })) || content;\n            const payload = {\n                ui,\n                content\n            };\n            const resolvePrevious = resolveFunc;\n            const nextRow = done ? null : new Promise((resolve)=>{\n                resolveFunc = resolve;\n            });\n            resolvePrevious({\n                next: nextRow,\n                ...payload\n            });\n            if (done) {\n                return;\n            }\n            await readChunk();\n        }\n        readChunk();\n        return next;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJckw7WUFDSixNQUFNLEVBQUVuQixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1KLE9BQU9LLElBQUk7WUFDekMsSUFBSSxDQUFDRixNQUFNO2dCQUNUdUcsV0FBV2xJLE9BQU80QjtZQUNwQjtZQUNBLE1BQU13TSxLQUFLLENBQUMsQ0FBQ3RMLEtBQUttTCxXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFRRyxFQUFFLEtBQUssT0FBTyxLQUFLLElBQUl0TCxHQUFHRSxJQUFJLENBQUNpTCxTQUFTO2dCQUFFL0Y7WUFBUSxFQUFDLEtBQU1BO1lBQzlHLE1BQU1jLFVBQVU7Z0JBQ2RvRjtnQkFDQWxHO1lBQ0Y7WUFDQSxNQUFNbUcsa0JBQWtCSDtZQUN4QixNQUFNSSxVQUFVM00sT0FBTyxPQUFPLElBQUlnRSxRQUFRLENBQUNDO2dCQUN6Q3NJLGNBQWN0STtZQUNoQjtZQUNBeUksZ0JBQWdCO2dCQUNkMUwsTUFBTTJMO2dCQUNOLEdBQUd0RixPQUFPO1lBQ1o7WUFDQSxJQUFJckgsTUFBTTtnQkFDUjtZQUNGO1lBQ0EsTUFBTXdNO1FBQ1I7UUFDQUE7UUFDQSxPQUFPeEw7SUFDVDtBQUNGO0FBeUJFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXp1cmUtb3Blbi1haS1hY2NlbGVyYXRvci8uL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcz84MWViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0cmVhbXMvYWktc3RyZWFtLnRzXG5pbXBvcnQge1xuICBjcmVhdGVQYXJzZXJcbn0gZnJvbSBcImV2ZW50c291cmNlLXBhcnNlclwiO1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpIHtcbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGV2ZW50U291cmNlUGFyc2VyO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIgPSBjcmVhdGVQYXJzZXIoXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCAmJiBldmVudC50eXBlID09PSBcImV2ZW50XCIgJiYgZXZlbnQuZGF0YSA9PT0gXCJbRE9ORV1cIiB8fCAvLyBSZXBsaWNhdGUgZG9lc24ndCBzZW5kIFtET05FXSBidXQgZG9lcyBzZW5kIGEgJ2RvbmUnIGV2ZW50XG4gICAgICAgICAgLy8gQHNlZSBodHRwczovL3JlcGxpY2F0ZS5jb20vZG9jcy9zdHJlYW1pbmdcbiAgICAgICAgICBldmVudC5ldmVudCA9PT0gXCJkb25lXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IGN1c3RvbVBhcnNlciA/IGN1c3RvbVBhcnNlcihldmVudC5kYXRhKSA6IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIuZmVlZCh0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGNiIHx8IHt9O1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShtZXNzYWdlKSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4obWVzc2FnZSk7XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgIGNvbnN0IGlzT3BlbkFJQ2FsbGJhY2tzID0gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiAhaXNPcGVuQUlDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gIHJldHVybiBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbFwiIGluIGNhbGxiYWNrcztcbn1cbmZ1bmN0aW9uIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCkge1xuICBsZXQgaXNTdHJlYW1TdGFydCA9IHRydWU7XG4gIHJldHVybiAodGV4dCkgPT4ge1xuICAgIGlmIChpc1N0cmVhbVN0YXJ0KSB7XG4gICAgICB0ZXh0ID0gdGV4dC50cmltU3RhcnQoKTtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICBpc1N0cmVhbVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuZnVuY3Rpb24gQUlTdHJlYW0ocmVzcG9uc2UsIGN1c3RvbVBhcnNlciwgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JUZXh0fWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKFwiUmVzcG9uc2UgZXJyb3I6IE5vIHJlc3BvbnNlIGJvZHlcIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VCb2R5U3RyZWFtID0gcmVzcG9uc2UuYm9keSB8fCBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG4gIHJldHVybiByZXNwb25zZUJvZHlTdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShpdGVyYWJsZSkge1xuICBsZXQgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgZWxzZVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgIH0sXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgdmFyIF9hO1xuICAgICAgYXdhaXQgKChfYSA9IGl0LnJldHVybikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoaXQsIHJlYXNvbikpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNoYXJlZC91dGlscy50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcbnZhciBuYW5vaWQgPSBjdXN0b21BbHBoYWJldChcbiAgXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICA3XG4pO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKGNvbXBsZXgpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBpZiAoIWNvbXBsZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIGlmICghY2h1bmspXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKTtcbiAgICByZXR1cm4gZGVjb2RlZC5tYXAoZ2V0U3RyZWFtU3RyaW5nVHlwZUFuZFZhbHVlKS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG59XG52YXIgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIHRleHQ6IDAsXG4gIGZ1bmN0aW9uX2NhbGw6IDEsXG4gIGRhdGE6IDJcbiAgLy8gdXNlcl9lcnI6IDM/XG59O1xudmFyIGlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUgPSAodHlwZSwgdmFsdWUpID0+IHZhbHVlLnN0YXJ0c1dpdGgoYCR7U3RyZWFtU3RyaW5nUHJlZml4ZXNbdHlwZV19OmApICYmIHZhbHVlLmVuZHNXaXRoKFwiXFxuXCIpO1xudmFyIGdldFN0cmVhbVN0cmluZyA9ICh0eXBlLCB2YWx1ZSkgPT4gYCR7U3RyZWFtU3RyaW5nUHJlZml4ZXNbdHlwZV19OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVxuYDtcbnZhciBnZXRTdHJlYW1TdHJpbmdUeXBlQW5kVmFsdWUgPSAobGluZSkgPT4ge1xuICBjb25zdCBmaXJzdFNlcGVyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGVyYXRvckluZGV4KTtcbiAgY29uc3QgdHlwZSA9IE9iamVjdC5rZXlzKFN0cmVhbVN0cmluZ1ByZWZpeGVzKS5maW5kKFxuICAgIChrZXkpID0+IFN0cmVhbVN0cmluZ1ByZWZpeGVzW2tleV0gPT09IE51bWJlcihwcmVmaXgpXG4gICk7XG4gIGNvbnN0IHZhbCA9IGxpbmUuc2xpY2UoZmlyc3RTZXBlcmF0b3JJbmRleCArIDEpO1xuICBsZXQgcGFyc2VkVmFsID0gdmFsO1xuICBpZiAoIXZhbCkge1xuICAgIHJldHVybiB7IHR5cGUsIHZhbHVlOiBcIlwiIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBwYXJzZWRWYWwgPSBKU09OLnBhcnNlKHZhbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIEpTT04gdmFsdWU6XCIsIHZhbCk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZSwgdmFsdWU6IHBhcnNlZFZhbCB9O1xufTtcbnZhciBDT01QTEVYX0hFQURFUiA9IFwiWC1FeHBlcmltZW50YWwtU3RyZWFtLURhdGFcIjtcblxuLy8gc3RyZWFtcy9zdHJlYW0tZGF0YS50c1xudmFyIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBudWxsO1xuICAgIC8vIGNsb3NpbmcgdGhlIHN0cmVhbSBpcyBzeW5jaHJvbm91cywgYnV0IHdlIHdhbnQgdG8gcmV0dXJuIGEgcHJvbWlzZVxuICAgIC8vIGluIGNhc2Ugd2UncmUgZG9pbmcgYXN5bmMgd29ya1xuICAgIHRoaXMuaXNDbG9zZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZVJlc29sdmVyID0gdm9pZCAwO1xuICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICAvLyBhcnJheSB0byBzdG9yZSBhcHBlbmRlZCBkYXRhXG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBzZWxmLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGdldFN0cmVhbVN0cmluZyhcImRhdGFcIiwgSlNPTi5zdHJpbmdpZnkoc2VsZi5kYXRhKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlbGYuZGF0YSA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHdhcm5pbmdUaW1lb3V0ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiVGhlIGRhdGEgc3RyZWFtIGlzIGhhbmdpbmcuIERpZCB5b3UgZm9yZ2V0IHRvIGNsb3NlIGl0IHdpdGggYGRhdGEuY2xvc2UoKWA/XCJcbiAgICAgICAgICApO1xuICAgICAgICB9LCAzZTMpIDogbnVsbDtcbiAgICAgICAgYXdhaXQgc2VsZi5pc0Nsb3NlZFByb21pc2U7XG4gICAgICAgIGlmICh3YXJuaW5nVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IHNlbGYuZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBnZXRTdHJlYW1TdHJpbmcoXCJkYXRhXCIsIEpTT04uc3RyaW5naWZ5KHNlbGYuZGF0YSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLmlzQ2xvc2VkUHJvbWlzZVJlc29sdmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgfVxuICBhcHBlbmQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpIHtcbiAgaWYgKCFleHBlcmltZW50YWxfc3RyZWFtRGF0YSkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShnZXRTdHJlYW1TdHJpbmcoXCJ0ZXh0XCIsIG1lc3NhZ2UpKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzXG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIHJldHVybiBleHRyYWN0KEpTT04ucGFyc2UoZGF0YSkpO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUoc3RyZWFtKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGNvbnN0IHRleHQgPSBleHRyYWN0KGNodW5rKTtcbiAgICBpZiAodGV4dClcbiAgICAgIHlpZWxkIHRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGNodW5rVG9UZXh0KCkge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW47XG4gIHJldHVybiAoanNvbikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfajtcbiAgICBpZiAoaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmICgoX2MgPSAoX2IgPSAoX2EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfYy5uYW1lKSkge1xuICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgIHJldHVybiBge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiJHsoX2UgPSAoX2QgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZC5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgO1xuICAgIH0gZWxzZSBpZiAoaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmICgoX2ggPSAoX2cgPSAoX2YgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZi5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpKSB7XG4gICAgICBjb25zdCBhcmd1bWVudENodW5rID0ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzO1xuICAgICAgbGV0IGVzY2FwZWRQYXJ0aWFsSnNvbiA9IGFyZ3VtZW50Q2h1bmsucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFwvXCIpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9cXGYvZywgXCJcXFxcZlwiKTtcbiAgICAgIHJldHVybiBgJHtlc2NhcGVkUGFydGlhbEpzb259YDtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKChfaSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLmZpbmlzaF9yZWFzb24pID09PSBcImZ1bmN0aW9uX2NhbGxcIiB8fCAoKF9qID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2ouZmluaXNoX3JlYXNvbikgPT09IFwic3RvcFwiKSkge1xuICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICByZXR1cm4gJ1wifX0nO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oXG4gICAgICBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikgJiYganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgPyBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA6IGlzQ29tcGxldGlvbihqc29uKSA/IGpzb24uY2hvaWNlc1swXS50ZXh0IDogXCJcIlxuICAgICk7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG52YXIgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgXCJpbnRlcm5hbF9vcGVuYWlfZm5fbWVzc2FnZXNcIlxuKTtcbmZ1bmN0aW9uIGlzQ2hhdENvbXBsZXRpb25DaHVuayhkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJkZWx0YVwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIGlzQ29tcGxldGlvbihkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJ0ZXh0XCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gT3BlbkFJU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIGNvbnN0IGNiID0gY2FsbGJhY2tzO1xuICBsZXQgc3RyZWFtO1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlKHJlcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gICAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSA/IHtcbiAgICAgICAgICAuLi5jYixcbiAgICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAuLi5jYlxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBBSVN0cmVhbShcbiAgICAgIHJlcyxcbiAgICAgIHBhcnNlT3BlbkFJU3RyZWFtKCksXG4gICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgPyB7XG4gICAgICAgIC4uLmNiLFxuICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLmNiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBpZiAoY2IgJiYgY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IFwiXCI7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gY2FsbGJhY2tzW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdIHx8IFtdO1xuICBjb25zdCBpc0NvbXBsZXhNb2RlID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGE7XG4gIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2RlKGNodW5rKTtcbiAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgY29uc3Qgc2hvdWxkSGFuZGxlQXNGdW5jdGlvbiA9IGlzRmlyc3RDaHVuayAmJiBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKTtcbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Z1bmN0aW9uU3RyZWFtaW5nSW4pIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIGlzQ29tcGxleE1vZGUgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoZ2V0U3RyZWFtU3RyaW5nKFwidGV4dFwiLCBtZXNzYWdlKSkgOiBjaHVua1xuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGlzRW5kT2ZGdW5jdGlvbiA9ICFpc0ZpcnN0Q2h1bmsgJiYgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCAmJiBpc0Z1bmN0aW9uU3RyZWFtaW5nSW47XG4gICAgICAgIGlmIChpc0VuZE9mRnVuY3Rpb24gJiYgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICAgICAgY29uc3QgYXJndW1lbnRzUGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZC5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyk7XG4gICAgICAgICAgbGV0IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXNcbiAgICAgICAgICBdO1xuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNQYXlsb2FkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHBheWxvYWQuZnVuY3Rpb25fY2FsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgcm9sZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIWZ1bmN0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgIGlzQ29tcGxleE1vZGUgPyBnZXRTdHJlYW1TdHJpbmcoXCJmdW5jdGlvbl9jYWxsXCIsIGFnZ3JlZ2F0ZWRSZXNwb25zZSkgOiBhZ2dyZWdhdGVkUmVzcG9uc2VcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGlzQ29tcGxleE1vZGUgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoZ2V0U3RyZWFtU3RyaW5nKFwidGV4dFwiLCBmdW5jdGlvblJlc3BvbnNlKSkgOiB0ZXh0RW5jb2Rlci5lbmNvZGUoZnVuY3Rpb25SZXNwb25zZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLi4uY2FsbGJhY2tzLFxuICAgICAgICAgICAgb25TdGFydDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFja3Mub25GaW5hbCA9IHZvaWQgMDtcbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gb3BlbkFJU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbWluZy10ZXh0LXJlc3BvbnNlLnRzXG52YXIgU3RyZWFtaW5nVGV4dFJlc3BvbnNlID0gY2xhc3MgZXh0ZW5kcyBSZXNwb25zZSB7XG4gIGNvbnN0cnVjdG9yKHJlcywgaW5pdCwgZGF0YSkge1xuICAgIGxldCBwcm9jZXNzZWRTdHJlYW0gPSByZXM7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHByb2Nlc3NlZFN0cmVhbSA9IHJlcy5waXBlVGhyb3VnaChkYXRhLnN0cmVhbSk7XG4gICAgfVxuICAgIHN1cGVyKHByb2Nlc3NlZFN0cmVhbSwge1xuICAgICAgLi4uaW5pdCxcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgW0NPTVBMRVhfSEVBREVSXTogZGF0YSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiLFxuICAgICAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHN0cmVhbVRvUmVzcG9uc2UocmVzLCByZXNwb25zZSwgaW5pdCkge1xuICByZXNwb25zZS53cml0ZUhlYWQoKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSB8fCAyMDAsIHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgfSk7XG4gIGNvbnN0IHJlYWRlciA9IHJlcy5nZXRSZWFkZXIoKTtcbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgIHJlYWQoKTtcbiAgICB9KTtcbiAgfVxuICByZWFkKCk7XG59XG5cbi8vIHN0cmVhbXMvaHVnZ2luZ2ZhY2Utc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVQYXJzZXIyKHJlcykge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlcy5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbSgoX2IgPSAoX2EgPSB2YWx1ZS50b2tlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRleHQpICE9IG51bGwgPyBfYiA6IFwiXCIpO1xuICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodmFsdWUuZ2VuZXJhdGVkX3RleHQgIT0gbnVsbCAmJiB2YWx1ZS5nZW5lcmF0ZWRfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQgPT09IFwiPC9zPlwiIHx8IHRleHQgPT09IFwiPHxlbmRvZnRleHR8PlwiIHx8IHRleHQgPT09IFwiPHxlbmR8PlwiKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gSHVnZ2luZ0ZhY2VTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZVBhcnNlcjIocmVzKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvY29oZXJlLXN0cmVhbS50c1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzTGluZXMobGluZXMsIGNvbnRyb2xsZXIpIHtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgeyB0ZXh0LCBpc19maW5pc2hlZCB9ID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICBpZiAoIWlzX2ZpbmlzaGVkKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcikge1xuICBsZXQgc2VnbWVudCA9IFwiXCI7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZTogY2h1bmssIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWdtZW50ICs9IHV0ZjhEZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IHNlZ21lbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL2cpO1xuICAgIHNlZ21lbnQgPSBsaW5lc0FycmF5LnBvcCgpIHx8IFwiXCI7XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmIChzZWdtZW50KSB7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IFtzZWdtZW50XTtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgY29udHJvbGxlci5jbG9zZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMyhyZXMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCByZWFkZXIgPSAoX2EgPSByZXMuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldFJlYWRlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gQ29oZXJlU3RyZWFtKHJlYWRlciwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBjcmVhdGVQYXJzZXIzKHJlYWRlcikucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhKVxuICApO1xufVxuXG4vLyBzdHJlYW1zL2FudGhyb3BpYy1zdHJlYW0udHNcbmZ1bmN0aW9uIHBhcnNlQW50aHJvcGljU3RyZWFtKCkge1xuICBsZXQgcHJldmlvdXMgPSBcIlwiO1xuICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICBpZiAoXCJlcnJvclwiIGluIGpzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtqc29uLmVycm9yLnR5cGV9OiAke2pzb24uZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgaWYgKCEoXCJjb21wbGV0aW9uXCIgaW4ganNvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGpzb24uY29tcGxldGlvbjtcbiAgICBpZiAoIXByZXZpb3VzIHx8IHRleHQubGVuZ3RoID4gcHJldmlvdXMubGVuZ3RoICYmIHRleHQuc3RhcnRzV2l0aChwcmV2aW91cykpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gdGV4dC5zbGljZShwcmV2aW91cy5sZW5ndGgpO1xuICAgICAgcHJldmlvdXMgPSB0ZXh0O1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlMihzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBjb25zdCB0ZXh0ID0gY2h1bmsuY29tcGxldGlvbjtcbiAgICBpZiAodGV4dClcbiAgICAgIHlpZWxkIHRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIEFudGhyb3BpY1N0cmVhbShyZXMsIGNiKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlMihyZXMpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQUlTdHJlYW0ocmVzLCBwYXJzZUFudGhyb3BpY1N0cmVhbSgpLCBjYikucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tc3RyZWFtLnRzXG5mdW5jdGlvbiBMYW5nQ2hhaW5TdHJlYW0oY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICBjb25zdCBydW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIGF3YWl0IHdyaXRlci5hYm9ydChlKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlU3RhcnQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmFkZChydW5JZCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUVuZCA9IGFzeW5jIChydW5JZCkgPT4ge1xuICAgIHJ1bnMuZGVsZXRlKHJ1bklkKTtcbiAgICBpZiAocnVucy5zaXplID09PSAwKSB7XG4gICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBzdHJlYW0ucmVhZGFibGUucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICAgKSxcbiAgICB3cml0ZXIsXG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIGhhbmRsZUxMTU5ld1Rva2VuOiBhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUodG9rZW4pO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTVN0YXJ0OiBhc3luYyAoX2xsbSwgX3Byb21wdHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluU3RhcnQ6IGFzeW5jIChfY2hhaW4sIF9pbnB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVuZDogYXN5bmMgKF9vdXRwdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbFN0YXJ0OiBhc3luYyAoX3Rvb2wsIF9pbnB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHN0cmVhbXMvcmVwbGljYXRlLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gUmVwbGljYXRlU3RyZWFtKHJlcywgY2IpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB1cmwgPSAoX2EgPSByZXMudXJscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0cmVhbTtcbiAgaWYgKCF1cmwpIHtcbiAgICBpZiAocmVzLmVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcy5lcnJvcik7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzdHJlYW0gVVJMIGluIFJlcGxpY2F0ZSByZXNwb25zZVwiKTtcbiAgfVxuICBjb25zdCBldmVudFN0cmVhbSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBY2NlcHQ6IFwidGV4dC9ldmVudC1zdHJlYW1cIlxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBBSVN0cmVhbShldmVudFN0cmVhbSwgdm9pZCAwLCBjYikucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfc3RyZWFtRGF0YSlcbiAgKTtcbn1cblxuLy8gc3RyZWFtcy9zdHJlYW1pbmctcmVhY3QtcmVzcG9uc2UudHNcbnZhciBleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVzLCBvcHRpb25zKSB7XG4gICAgbGV0IHJlc29sdmVGdW5jID0gKCkgPT4ge1xuICAgIH07XG4gICAgbGV0IG5leHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVzb2x2ZUZ1bmMgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGxldCBjb250ZW50ID0gXCJcIjtcbiAgICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcbiAgICBjb25zdCByZWFkZXIgPSByZXMuZ2V0UmVhZGVyKCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZENodW5rKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmICghZG9uZSkge1xuICAgICAgICBjb250ZW50ICs9IGRlY29kZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCB1aSA9ICgoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCB7IGNvbnRlbnQgfSkpIHx8IGNvbnRlbnQ7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB1aSxcbiAgICAgICAgY29udGVudFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmVGdW5jO1xuICAgICAgY29uc3QgbmV4dFJvdyA9IGRvbmUgPyBudWxsIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcmVzb2x2ZUZ1bmMgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICByZXNvbHZlUHJldmlvdXMoe1xuICAgICAgICBuZXh0OiBuZXh0Um93LFxuICAgICAgICAuLi5wYXlsb2FkXG4gICAgICB9KTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRDaHVuaygpO1xuICAgIH1cbiAgICByZWFkQ2h1bmsoKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEFJU3RyZWFtLFxuICBBbnRocm9waWNTdHJlYW0sXG4gIENPTVBMRVhfSEVBREVSLFxuICBDb2hlcmVTdHJlYW0sXG4gIEh1Z2dpbmdGYWNlU3RyZWFtLFxuICBMYW5nQ2hhaW5TdHJlYW0sXG4gIE9wZW5BSVN0cmVhbSxcbiAgUmVwbGljYXRlU3RyZWFtLFxuICBTdHJlYW1TdHJpbmdQcmVmaXhlcyxcbiAgU3RyZWFtaW5nVGV4dFJlc3BvbnNlLFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgY3JlYXRlQ2h1bmtEZWNvZGVyLFxuICBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyLFxuICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIsXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhLFxuICBleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZSxcbiAgZ2V0U3RyZWFtU3RyaW5nLFxuICBnZXRTdHJlYW1TdHJpbmdUeXBlQW5kVmFsdWUsXG4gIGlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUsXG4gIG5hbm9pZCxcbiAgcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSxcbiAgc3RyZWFtVG9SZXNwb25zZSxcbiAgdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXJcbn07XG4iXSwibmFtZXMiOlsiY3JlYXRlUGFyc2VyIiwiY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lciIsImN1c3RvbVBhcnNlciIsInRleHREZWNvZGVyIiwiVGV4dERlY29kZXIiLCJldmVudFNvdXJjZVBhcnNlciIsIlRyYW5zZm9ybVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsImV2ZW50IiwidHlwZSIsImRhdGEiLCJ0ZXJtaW5hdGUiLCJwYXJzZWRNZXNzYWdlIiwiZW5xdWV1ZSIsInRyYW5zZm9ybSIsImNodW5rIiwiZmVlZCIsImRlY29kZSIsImNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyIiwiY2IiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwiYWdncmVnYXRlZFJlc3BvbnNlIiwiY2FsbGJhY2tzIiwib25TdGFydCIsIm1lc3NhZ2UiLCJlbmNvZGUiLCJvblRva2VuIiwiZmx1c2giLCJpc09wZW5BSUNhbGxiYWNrcyIsImlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIiwib25Db21wbGV0aW9uIiwib25GaW5hbCIsInRyaW1TdGFydE9mU3RyZWFtSGVscGVyIiwiaXNTdHJlYW1TdGFydCIsInRleHQiLCJ0cmltU3RhcnQiLCJBSVN0cmVhbSIsInJlc3BvbnNlIiwib2siLCJib2R5IiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW0iLCJkb25lIiwidmFsdWUiLCJyZWFkIiwiZXJyb3JUZXh0IiwiZXJyb3IiLCJFcnJvciIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJwaXBlVGhyb3VnaCIsImNsb3NlIiwicmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwicHVsbCIsIm5leHQiLCJjYW5jZWwiLCJyZWFzb24iLCJfYSIsInJldHVybiIsImNhbGwiLCJjdXN0b21BbHBoYWJldCIsIm5hbm9pZCIsImNyZWF0ZUNodW5rRGVjb2RlciIsImNvbXBsZXgiLCJkZWNvZGVyIiwic3RyZWFtIiwiZGVjb2RlZCIsInNwbGl0IiwiZmlsdGVyIiwibGluZSIsIm1hcCIsImdldFN0cmVhbVN0cmluZ1R5cGVBbmRWYWx1ZSIsIkJvb2xlYW4iLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsImZ1bmN0aW9uX2NhbGwiLCJpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiZ2V0U3RyZWFtU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImZpcnN0U2VwZXJhdG9ySW5kZXgiLCJpbmRleE9mIiwicHJlZml4Iiwic2xpY2UiLCJPYmplY3QiLCJrZXlzIiwiZmluZCIsImtleSIsIk51bWJlciIsInZhbCIsInBhcnNlZFZhbCIsInBhcnNlIiwiZSIsImNvbnNvbGUiLCJDT01QTEVYX0hFQURFUiIsImV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhIiwiY29uc3RydWN0b3IiLCJlbmNvZGVyIiwiaXNDbG9zZWRQcm9taXNlIiwiaXNDbG9zZWRQcm9taXNlUmVzb2x2ZXIiLCJpc0Nsb3NlZCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2VsZiIsImxlbmd0aCIsImVuY29kZWREYXRhIiwid2FybmluZ1RpbWVvdXQiLCJwcm9jZXNzIiwic2V0VGltZW91dCIsIndhcm4iLCJjbGVhclRpbWVvdXQiLCJhcHBlbmQiLCJwdXNoIiwiY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyIiwiZXhwZXJpbWVudGFsX3N0cmVhbURhdGEiLCJwYXJzZU9wZW5BSVN0cmVhbSIsImV4dHJhY3QiLCJjaHVua1RvVGV4dCIsInN0cmVhbWFibGUiLCJ0cmltU3RhcnRPZlN0cmVhbSIsImlzRnVuY3Rpb25TdHJlYW1pbmdJbiIsImpzb24iLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9pIiwiX2oiLCJpc0NoYXRDb21wbGV0aW9uQ2h1bmsiLCJjaG9pY2VzIiwiZGVsdGEiLCJuYW1lIiwiYXJndW1lbnRzIiwiYXJndW1lbnRDaHVuayIsImVzY2FwZWRQYXJ0aWFsSnNvbiIsInJlcGxhY2UiLCJmaW5pc2hfcmVhc29uIiwiY29udGVudCIsImlzQ29tcGxldGlvbiIsIl9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wiLCJPcGVuQUlTdHJlYW0iLCJyZXMiLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyIiwiaXNGaXJzdENodW5rIiwiYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlIiwiZnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJpc0NvbXBsZXhNb2RlIiwic2hvdWxkSGFuZGxlQXNGdW5jdGlvbiIsImlzRW5kT2ZGdW5jdGlvbiIsInBheWxvYWQiLCJhcmd1bWVudHNQYXlsb2FkIiwibmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJmdW5jdGlvblJlc3BvbnNlIiwicmVzdWx0Iiwicm9sZSIsImZpbHRlcmVkQ2FsbGJhY2tzIiwib3BlbkFJU3RyZWFtIiwiU3RyZWFtaW5nVGV4dFJlc3BvbnNlIiwiUmVzcG9uc2UiLCJpbml0IiwicHJvY2Vzc2VkU3RyZWFtIiwic3RhdHVzIiwiaGVhZGVycyIsInN0cmVhbVRvUmVzcG9uc2UiLCJ3cml0ZUhlYWQiLCJ0aGVuIiwiZW5kIiwid3JpdGUiLCJjcmVhdGVQYXJzZXIyIiwidG9rZW4iLCJnZW5lcmF0ZWRfdGV4dCIsIkh1Z2dpbmdGYWNlU3RyZWFtIiwidXRmOERlY29kZXIiLCJwcm9jZXNzTGluZXMiLCJsaW5lcyIsImlzX2ZpbmlzaGVkIiwicmVhZEFuZFByb2Nlc3NMaW5lcyIsInNlZ21lbnQiLCJsaW5lc0FycmF5IiwicG9wIiwiY3JlYXRlUGFyc2VyMyIsIkNvaGVyZVN0cmVhbSIsInBhcnNlQW50aHJvcGljU3RyZWFtIiwicHJldmlvdXMiLCJjb21wbGV0aW9uIiwic3RyZWFtYWJsZTIiLCJBbnRocm9waWNTdHJlYW0iLCJMYW5nQ2hhaW5TdHJlYW0iLCJ3cml0ZXIiLCJ3cml0YWJsZSIsImdldFdyaXRlciIsInJ1bnMiLCJTZXQiLCJoYW5kbGVFcnJvciIsInJ1bklkIiwiZGVsZXRlIiwicmVhZHkiLCJhYm9ydCIsImhhbmRsZVN0YXJ0IiwiYWRkIiwiaGFuZGxlRW5kIiwic2l6ZSIsInJlYWRhYmxlIiwiaGFuZGxlcnMiLCJoYW5kbGVMTE1OZXdUb2tlbiIsImhhbmRsZUxMTVN0YXJ0IiwiX2xsbSIsIl9wcm9tcHRzIiwiaGFuZGxlTExNRW5kIiwiX291dHB1dCIsImhhbmRsZUxMTUVycm9yIiwiaGFuZGxlQ2hhaW5TdGFydCIsIl9jaGFpbiIsIl9pbnB1dHMiLCJoYW5kbGVDaGFpbkVuZCIsIl9vdXRwdXRzIiwiaGFuZGxlQ2hhaW5FcnJvciIsImhhbmRsZVRvb2xTdGFydCIsIl90b29sIiwiX2lucHV0IiwiaGFuZGxlVG9vbEVuZCIsImhhbmRsZVRvb2xFcnJvciIsIlJlcGxpY2F0ZVN0cmVhbSIsInVybCIsInVybHMiLCJldmVudFN0cmVhbSIsImZldGNoIiwibWV0aG9kIiwiQWNjZXB0IiwiZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2UiLCJvcHRpb25zIiwicmVzb2x2ZUZ1bmMiLCJyZWFkQ2h1bmsiLCJ1aSIsInJlc29sdmVQcmV2aW91cyIsIm5leHRSb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet customAlphabet = (alphabet, defaultSize = 21)=>{\n    return (size = defaultSize)=>{\n        let id = \"\";\n        let i = size;\n        while(i--){\n            id += alphabet[Math.random() * alphabet.length | 0];\n        }\n        return id;\n    };\n};\nlet nanoid = (size = 21)=>{\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUEsY0FDRjtBQUNGLElBQUlDLGlCQUFpQixDQUFDQyxVQUFVQyxjQUFjLEVBQUU7SUFDOUMsT0FBTyxDQUFDQyxPQUFPRCxXQUFXO1FBQ3hCLElBQUlFLEtBQUs7UUFDVCxJQUFJQyxJQUFJRjtRQUNSLE1BQU9FLElBQUs7WUFDVkQsTUFBTUgsUUFBUSxDQUFDLEtBQU1NLE1BQU0sS0FBS04sU0FBU08sTUFBTSxHQUFJLEVBQUU7UUFDdkQ7UUFDQSxPQUFPSjtJQUNUO0FBQ0Y7QUFDQSxJQUFJSyxTQUFTLENBQUNOLE9BQU8sRUFBRTtJQUNyQixJQUFJQyxLQUFLO0lBQ1QsSUFBSUMsSUFBSUY7SUFDUixNQUFPRSxJQUFLO1FBQ1ZELE1BQU1MLFdBQVcsQ0FBQyxLQUFNUSxNQUFNLEtBQUssS0FBTSxFQUFFO0lBQzdDO0lBQ0EsT0FBT0g7QUFDVDtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2F6dXJlLW9wZW4tYWktYWNjZWxlcmF0b3IvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzPzM3NGYiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIGxldCBpID0gc2l6ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlkICs9IGFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoKSB8IDBdXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG59XG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSAnJ1xuICBsZXQgaSA9IHNpemVcbiAgd2hpbGUgKGktLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogNjQpIHwgMF1cbiAgfVxuICByZXR1cm4gaWRcbn1cbmV4cG9ydCB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQgfVxuIl0sIm5hbWVzIjpbInVybEFscGhhYmV0IiwiY3VzdG9tQWxwaGFiZXQiLCJhbHBoYWJldCIsImRlZmF1bHRTaXplIiwic2l6ZSIsImlkIiwiaSIsIk1hdGgiLCJyYW5kb20iLCJsZW5ndGgiLCJuYW5vaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ })

};
;